#!/usr/bin/perl

use strict;
use warnings;
use Symbol;
use Data::Dumper;
use IO::Select;

# pragma - allow (?{ code }) assertions in dynamically generated regexen.
# This let's me do named captures with $^N
use re 'eval';

# Things you'll need to have installed:
use Regexp::Common qw(RE_ALL);
use Parse::RecDescent;

$::RD_ERRORS = 1;
$::RD_HINT = 1;

my @logrefs;

my $PATTERNS;
	
# Pattern-space wildcards, used as %WILDCARD% in the pattern config
my %MATCH = (
	USERNAME => '\\w+',
	IP => $RE{net}{IPv4},
	PORT => '\\d+',
	COUNT => '\\d+',
);

my $config = readconfig();
#print Dumper($config);
setup($config);

# Keep state
my $state;
my $select = IO::Select->new();

foreach (keys(%$config)) {
	next if ($_ eq "patterns");
	my $s = Symbol::gensym;
	my $command = $_;
	if ($config->{$_}->{"type"} eq 'file') {
		$command = "tail -0 -f $_";
	}
	print "Running $command\n";
	open($s, "$command |");
	$select->add($s);
	$state->{"map"}->{$s} = $_;
}

# Loop for data for as long as our love shall last...
while(1) {
	last if ($select->count() == 0);
	my @ready = $select->can_read(1);
	map { readlog($_) } @ready;
}

print "$0: Nothing left to do... exiting\n";
exit(0);

sub readlog {
	my $logh = shift;
	my $buffer = $state->{"buffers"}->{$logh} || "";
	my $bytes = sysread($logh, $buffer, 1024, length($buffer));
	if ($bytes == 0) {
		print "finished: " . $state->{"map"}->{$logh} . "\n";
		$select->remove($logh);
		close($logh);
	}
	while ($buffer =~ s!(.*)\n!!) {
		#print $state->{"map"}->{$logh} . "> $1\n";
		handle($state->{"map"}->{$logh},$1);
	}
	#$state->{"buffers"}->{$logh} = $buffer;
}

sub handle {
	my ($log,$line) = @_;
	chomp($line);
	#print $log . "> " . $line;
	my $last = { line => $line };

	my $patterns = $PATTERNS->{$log};
	foreach my $pattern (keys(%{$patterns})) {
		# "fix" the line, turn it into a regex.
		my $regex = pattern2regex($pattern);
		print "Regex: $regex\n";
		#print "Match: " . ($line =~ /$regex/)  . "\n";

		# The regex match will store keys in this hash
		my %values;
		if ($line =~ /$regex/) { 
			# Handle if we're over the threshold
			my $pat = $PATTERNS->{$log}->{$pattern};
			my $keyname;
			my $fileconf = $config->{$log}->{"types"}->{$pat};
			$keyname = join ("/", $pat, map { "$_=>$values{$_}" } keys(%values));
			$state->{$keyname}->{"time"} ||= time();
			$state->{$keyname}->{"count"}++;

			#print "-\n";
			#print "Line: $line\n";
			#print "Key: $keyname\n";
			#print "Matched rule: $keyname\n";
			#print "Threshold [$keyname]: " . $state->{$keyname}->{"count"} . "/" . $fileconf->{"threshold"} . "\n";
			#print "Time: " . (time() - $state->{$keyname}->{"time"}) . "/" . $fileconf->{"interval"} . "\n";
			#print "\n";

			if ($state->{$keyname}->{"count"} >= $fileconf->{"threshold"})  {
				if ($fileconf->{"interval"} == 0 
					 || ((time() - $state->{$keyname}->{"time"}) <= $fileconf->{"interval"})) { 
					map { 
						my ($cmd,$type) = ($_->{"string"}, $_->{"type"});
						if ($type eq 'command') {
							$cmd = meta2string($cmd, \%values);
							print "Executing ($keyname): $cmd\n";
							system($cmd);
						} else {
							$cmd = "package $keyname;\n$cmd";
							print "!!!\n$cmd\n!!!\n";
							eval $cmd;
						}
					} @{$fileconf->{"reactions"}};
				} else { 
					$state->{$keyname}->{"time"} = time();
				}
				$state->{$keyname}->{"count"} = 0;
			}
			$last->{"values"} = %values;
			$last->{"handler"} = $PATTERNS->{$log}->{$pattern};
		}
	}
	$state->{"last"}->{$log} = $last;
}

sub pattern2regex {
	my $pattern = shift;
	my $regex = $pattern;
	my $orig = $pattern;

	my $rounds = 0;
	my $count;
	do {
		$count = 0;
		map { $regex =~ s/%($_)%/($MATCH{$_})(?{\$values{$1} = \$^N})/g; } keys(%MATCH);
		$rounds++;
		if ($rounds > 10) {
			print STDERR "!!! Deep recursion translating '$orig'\n";
			last;
		}
	} while ($count > 0);

	return $regex;
}

sub meta2string {
	my $meta = shift;
	my $values = shift;
	my $orig = $meta;

	my $rounds = 0;
	my $count;
	do {
		$count = 0;
		map { $count += $meta =~ s/%($_)%/$values->{$_}/g; } keys(%MATCH);
		$rounds++;
		if ($rounds > 10) {
			print STDERR "!!! Deep recursion translating '$orig'\n";
			last;
		}
	} while ($count > 0);

	return $meta;
}

sub readconfig {
	my $cfname = "logwatch.conf";
	my $grammar = << 'GRAMMAR';
config: <rulevar: local $config = { }>
config: (file | pattern | ignorable | error)(s) /\Z/ { $return = $config }
ignorable: (comment | blankline)(s)
comment: /#[^\n]*/
blankline: /^\s*\n/

error: { printf STDERR "Error on line: $thisline? Failed at: $text"  }

string: /((?:\")(?:[^\\\"]*(?:\\.[^\\\"]*)*)(?:\")|(?:\')(?:[^\\\']*(?:\\.[^\\\']*)*)(?:\')|(?:\`)(?:[^\\\`]*(?:\\.[^\\\`]*)*)(?:\`))/ { $return = substr($item[1],1,-1) }
#string: <perl_quotelike> { $return = $item[1]->[2] }
number: /\d+/
word: /\w+/
perlblock: <perl_codeblock>

pattern: <rulevar: local $pattern = { }>
pattern: 'patterns' '{' (pattern_entry)(s) '}' ';' { $config->{"patterns"} = $pattern }
pattern_entry: pattern_name '=' pattern_string ';' { $pattern->{$item[1]} = $item[3] }
pattern_name: word
pattern_string: string

file: <rulevar: local $file = { }>
file: filespec filename '{' file_entry(?) '}' ';' { $config->{$item[2]} = $file }
filespec: ('file' | 'exec') { $file->{'type'} = $item[1] }
filename: string
file_entry: (file_entry_line | ignorable)(s)
file_entry_line: (syslog | type) ';'

syslog: 'syslog' '=' number { $file->{"syslog"} = $item[3] }

type: <rulevar: local $type = { }>
type: 'type' typename '{' type_entry '}' { $file->{"types"}->{$item[2]} = $type }
typename: string
type_entry: (((match | threshold | interval | reaction) ';') | ignorable)(s)

match: 'match' '=' string { push(@{$type->{"matches"}},$item[3]) }
threshold: 'threshold' '=' number { $type->{"threshold"} = $item[3] }
interval: 'interval' '=' number { $type->{"interval"} = $item[3] }
reaction: 'reaction' '=' reactionspec { push(@{$type->{"reactions"}}, $item[3]) }
reactionspec: string { $return = { type => "command", string => $item[1] } } 
				  | perlblock  { $return = { type => "perl", string => $item[1] } }
GRAMMAR

	my $parser = Parse::RecDescent->new($grammar);
	my $config;
	open(CONFIG, "logwatch.conf") or return;
	undef $/;
	$config = $parser->config(<CONFIG>);
	close(CONFIG);

	return $config;
}

sub setup {
	my $config = shift;
	print "Files to watch: " . join(", ", keys(%$config)) . "\n";
	foreach my $file (keys(%{$config})) {
		print "File: $file\n";
		my $matches = $config->{$file}->{"types"};
		my $matchhash;
		foreach my $match (keys(%{$matches})) {
			print "Match: $match\n";
			foreach my $string (@{$matches->{$match}->{"matches"}}) {
				print "String: $string\n";
				$matchhash->{$string} = $match;
			}
			$matches->{$match}->{"interval"} ||= 0;
			$matches->{$match}->{"threshold"} ||= 0;

			# Normalize perl blocks ?
			map {
				if ($_->{"type"} eq 'perl') {
					$_->{"string"} =~ s/^\s*{\s*(.*)\s*}\s*$/$1/;
					print "Perl: " . $_->{"string"} . "\n";
				}
			} @{$matches->{$match}->{"reactions"}};
				
		}
		$PATTERNS->{$file} = $matchhash;
	}

	foreach my $pattern (keys(%{$config->{"patterns"}})) {
		$MATCH{$pattern} = $config->{"patterns"}->{$pattern};
	}
}
