#!/usr/bin/perl
# $Id$
#
# Filter mail output from mhl (which should basically be the entire mail)
# 
#  Features:
#    - Automatically open html mail in w3m (see $BROWSER)
#    - Automagically verify pgp signatures
#

use strict;

#open(STDERR,">> /u9/psionic/mail/mflog") or die(":( $!");

# Basic setup and shenanigans! {{{
my $TMP = `grep ^nmh-storage: $ENV{HOME}/.mh_profile`;
if ($TMP) {
   chomp($TMP);
   $TMP =~ s/^nmh-storage:\s+//;
} else {
   $TMP = "/tmp";
}
my %viewers = (
   # Web Browsers
   'browsers'   => ['w3m', 'links', 'lynx'],
   'lynx' 	=> "lynx -force_html -vikeys",
   'links' 	=> "links",
   'w3m' 	=> "| w3m -title -T text/html",

   # Pagers
   'pagers'	=> ['envpager', 'less', 'pg', 'more'],
   'less' 	=> "| less",
   'more' 	=> "| more",
   'pg' 	=> "| pg",
   'envpager'	=> "| " .$ENV{'PAGER'},

   # Editors
   'editors'	=> ['enveditor', 'vi', 'pico', 'joe', 'emacs'],
   'vi'		=> "vi",
   'emacs'	=> "emacs",
   'pico'	=> "pico",
   'joe'	=> "joe",
   'enveditor'	=> $ENV{'EDITOR'},

   # A last resort.
   'lastresort' => ['cat'],
   'cat' 	=> "| cat -v",

   # Debug
   'debug'	=> ['devnull'],
   'devnull'	=> '> /dev/null'
);
my $VBROWSER;
my (@v); 

# UNCOMMENT TO SEND MAIL TO /dev/null, DEBUGGING
#push(@v,@{$viewers{debug}});
#push(@v, @{$viewers{lastresort}});

push(@v, @{$viewers{browsers}}); 
push(@v, @{$viewers{pagers}}); 
push(@v, @{$viewers{editors}}); 
push(@v, @{$viewers{lastresort}});

foreach my $viewer (@v) {
   my $rview = $viewers{"$viewer"};
   if ($rview =~ m/^\s*>/) {
      $VBROWSER = $viewers{$viewer};
      last;
   }
   $rview =~ s/^(\|?\s+)?([^\s]+)(\s?.*)$/$2/;
   foreach (split(":",$ENV{PATH})) {
      $VBROWSER = $viewers{$viewer} if (-x "$_/$rview");
   }
   last if ($VBROWSER);
}
print "Using this viewer: $VBROWSER\n";
#exit;
my $BROWSER = $VBROWSER;;
if ($VBROWSER !~ /^\|/) {
   $BROWSER = "> /tmp/" . mktemp();
}

my $HTML_ENABLE;
$HTML_ENABLE = 1 if ($VBROWSER =~ /(w3m|links|lynx)/);
my $MHL_PROG = "/usr/local/libexec/nmh/mhl";
my $MHL_HTML_OPTS = "-form mhl.html";
my $MHL_PLAIN_OPTS = "-form mhl.plaintext";
my $MHL_OPTS = ($HTML_ENABLE) ? $MHL_HTML_OPTS : $MHL_PLAIN_OPTS;

# This was stolen from my .muttrc - I'll need to come up with a decent
# parser for these lines eventually.
my %pgp = (
pgp_verify_command => "gpg --no-secmem-warning --quiet --no-verbose --batch --output - --verify %s %f"
	 );
# Plain-text types to be displayed normally without filtration:
my @plaintext_types = ( 
   'text/.*', 
   'message/delivery-status', 
   );

#}}}

# Set $mail, $folder, $base, other useful variables. {{{
my ($mail) = $ARGV[0];
my ($folder) = `folder -fast`; chomp($folder);
my $base;
if ($folder !~ m,^/,) {
   ($base) = `grep '^Path:' $ENV{HOME}/.mh_profile`;
   chomp($base);
   $base =~ s/^Path:\s+(.*)\/?$/$1/;
}
my ($file) = "$base/$folder/$mail";

my $browser_content_type;
my $browser_done_headers;
#}}}

# Read in the mail headers {{{

my %headers;
my @order;
my ($is_html,$done_headers) = (0,0);
my $header;
my $from_line;

print STDERR "Reading mail headers\n";
open(MAIL, "< $file") or die("Unable to open $file.\n$!\n");

$from_line = <MAIL>; chomp($from_line);

my $boundary;
my %ticks;
my $lookforctype = 0;
my @part_types;
while (<MAIL>) {
   chomp();

   if ($done_headers == 0) {
      if (m/^$/) {
	 $done_headers = 1;
	 next;
      }

      if (s/^([A-Za-z-]+):\s+//) {
	 my $a = $1;
	 unless ($a =~ m/^Content-Type$/i) {
	    $ticks{$1}++;
	    $a .= "_" . $ticks{$1};
	 }

	 $header = $a;
	 push(@order,$header);
      }
      if (defined($headers{$header})) {
	 $headers{$header} .= "\n" . $_;
      } else {
	 $headers{$header} .= $_;
      }

   } else {
      chomp();
      unless ($boundary) {
	 ($boundary) = grep(/^content-type$/i,keys(%headers)); 
	 $boundary = $headers{$boundary};
	 $boundary =~ m/boundary="([^"]+)"/; $boundary = $1;
      }

      #print $_ . "\n";
      if ($_ eq "--$boundary") {
	 $lookforctype = 1;
	 next;
      }

      if ($lookforctype == 1) {
	 if (m,^Content-Type: ([a-z-]+/[a-z-]+),i) {
	    #print "Part " . (scalar(@part_types) + 1) . ": $1\n";
	    push(@part_types,$1);
	    $lookforctype = 0;
	 }
      }

   }
} 
close(MAIL);
# We're done reading the headers }}}

#{{{ Useful Variables (content-typpe, tempfile template, ...)
my ($ctype) = grep(/^content-type$/i,keys(%headers)); 
$ctype = $headers{$ctype};
my $fr = $folder; $fr =~ s,^.*/([^/]+)$,$1,;
my $template = "$mail";
my $templatereg = '^'.$mail.'\.[0-9]+\.';
#}}}

if ($ctype =~ m,^multipart/,i) { # handle multipart mail{{{
   print STDERR "Parsing multipart mail ($ctype)\n";
   system("rm $TMP/$template* > /dev/null 2>&1");

   my %parts;

   my $partlist = `mhlist -noheaders`;
   my @fileparts;
   foreach (split("\n",$partlist)) {
      next if (m,multipart,i);
      chomp(); s/^\s+//;
      my ($part,$type,$size,$desc) = split(/\s+/,$_,4);
      $parts{$part} = { 'type' => $type, 'size' => $size, 
                        'desc' => $desc, 'part' => $part };
      my $storefile = `mhstore -part $part 2>&1`;
      $storefile =~ s/^.*as file //; chomp($storefile);
      $parts{$part}->{'file'} = $storefile;
      push(@fileparts,$storefile);
   }

   #system("mhstore");

   #print "Files: " . join(" | ", @fileparts) . "\n";

   # If part 2 is html, then open it first assuming that this email was dually
   # sent as text/plain and text/html.
   my $mailpart;
   if ( ($HTML_ENABLE) &&
        ($parts{2}{type} =~ m/\.html$/ && ($mailpart = $parts{2})) || 
	($parts{1}{type} =~ m/\.html$/ && ($mailpart = $parts{1})) ) {
      my $tmpfile = "$TMP/.headers.$fr.$mail";
      print STDERR "Starting browser (Probably HTML Mail)\n";

      open(BROWSER, "$BROWSER");
      browser_set_content_type("text/plain") unless ($HTML_ENABLE);
      browser_set_content_type("text/html") if ($HTML_ENABLE);;

      mhl_write_headers($tmpfile);
      browser_print("< $tmpfile","text/mail_header");
      browser_print("< $TMP/$mailpart");

      close(BROWSER);
      check_open_browser();

      #system("rm $tmpfile");
   } else {
      # This doesn't appear to be an html mail, let's deduce what it is...

      print STDERR "Starting browser (Multipart mail)\n";

      open(BROWSER, "$BROWSER");
      browser_set_content_type("text/plain") unless ($HTML_ENABLE);
      browser_set_content_type("text/html") if ($HTML_ENABLE);;

      print STDERR "> Writing mail header\n";
      my $tmpfile = "$TMP/.headers.$fr.$mail";
      mhl_write_headers($tmpfile);
      browser_print("< $tmpfile","text/mail_header");

      # Do PGP stuff first?
      if (scalar(grep(/application\/pgp-signature/,@part_types)) > 0) { 
	 # pgp-signed email {{{
	 print STDERR "pgp signature found, invoking pgp... ";
	 my ($plain, $sig, $plaintype);
	 my ($pidx, $sidx);
	 my $count = 0;
	 foreach my $part (@fileparts) {
	    my $type = $part_types[$count];
	    if ( (!defined($plain)) && ($type =~ m,text/(plain|html),) ) {
	       $plain = $part;
	       $plaintype = $type;
	       $pidx = $count;
	    }
	    if ( (!defined($sig)) && ($type eq 'application/pgp-signature') ) {
	       $sig = $part;
	       $sidx = $count;
	    } 
	    $count++;
	 }

	 my $pgp_verify = $pgp{'pgp_verify_command'};
	 $pgp_verify =~ s,%s,$sig,;
	 $pgp_verify =~ s,%f,$plain,;

	 browser_print("$pgp_verify 2>&1 |", "text/plain",2);

	 undef($parts{$sidx});
	 print STDERR "done.\n"

	 #}}}
      }

      print STDERR "Writing first part\n";
      browser_print("< " . $fileparts[0], $parts{1}{'type'});

      undef($parts{1});

      mime_for_you(\%parts,@fileparts);

      close(BROWSER);
      check_open_browser();

      system("rm $tmpfile");
   }

   foreach (@fileparts) {
      system("rm $_");
   }
#}}}
} else { # Not multipart mail. {{{

   print STDERR "Starting browser... (Plain ordinary mail)\n";
   open(BROWSER,"$BROWSER") or die(":( $!");
   browser_set_content_type("text/plain") unless ($HTML_ENABLE);
   browser_set_content_type("text/html") if ($HTML_ENABLE);;

   browser_print("$MHL_PROG $MHL_OPTS $mail |","$ctype");
   close(BROWSER);
   check_open_browser();

} # }}}

sub mhl_write_headers { #{{{
   my ($out) = shift;

   open(MHLWRITE, "| $MHL_PROG $MHL_OPTS > $out") or
      die("Failed trying to pipe to $MHL_PROG\n$!\n"); 

   print MHLWRITE "$from_line\n";
   foreach (@order) {
      my $a = $_;
      $a =~ s/^([A-Za-z-]+)_[0-9]+$/\1/;

      print MHLWRITE "$a:  $headers{$_}\n";
   }
   close(MHLWRITE);
} #}}}

sub browser_print { #{{{
   my ($what,$type,$splitter) = @_;
   my $contents;

   if (ref($what) eq 'GLOB') {
      $contents = $what;
   } else {
      open($contents,$what) 
	 or die("Unable to open $what for reading.\nreason> $!\n");
   }

   my ($not_real_html);
   if ($browser_done_headers) {
      if ($browser_content_type eq 'text/html')  {
	 if ($browser_content_type ne $type) {
	    if ($type eq 'text/mail_header') {
	       $not_real_html = 2;
	    } else {
	       $not_real_html = 1;
	    }
	 }
      } else {
	 if ($type eq 'text/mail_header') {
	    $not_real_html = 2;
	 } else {
	    $not_real_html = 1;
	 }
      }
   } else {
      $not_real_html = 2;
   }

   if ($splitter == 1) {
      if ($HTML_ENABLE) { 
	 print BROWSER "<hr>";
      } else {
         print "\033[1m;--------\033[0m;";
      }
   }

   my $header_cc_kludge = 0;
   while (<$contents>) { 
      if ( ($not_real_html) && ($HTML_ENABLE) ) {
	 if ($not_real_html == 1) {;
	    s/</&lt;/g; 
	    s/>/&gt;/g 
	 }
	 if ($not_real_html == 2) {
	    s,<([^(html|head|title|body|br|hr|>)]*)>,TEST $1 TEST,g 
	 }

	 # Lame kludge :(
	 if (!$browser_done_headers) {
	    print BROWSER "<br>\n" if (($header_cc_kludge) && (m/^Subject:/));
	    $header_cc_kludge = 1 if ((!$header_cc_kludge) && (m/^cc:/));
	 }

         print BROWSER $_;
	 print BROWSER "<br>\n" if ($not_real_html != 2);

	 if ((!$browser_done_headers) && (m/^(\n|<hr>)$/)) {
	    $browser_done_headers = 1;
	    if ($browser_content_type eq 'text/html')  {
	       $not_real_html = 1 if ($browser_content_type ne $type);
	    } else {
	       $not_real_html = 1;
	    }
	 }
      } else {
	 print BROWSER $_;
      }

   }

   if ($splitter == 2) {
      if ($HTML_ENABLE) { 
	 print BROWSER "<hr>";
      } else {
         print "\033[1m;--------\033[0m;";
      }
   }

   close($contents) if (ref($what) ne 'GLOB');
} #}}}

sub browser_set_content_type { #{{{
   my $type = shift;

   $browser_content_type = $type;
} #}}}

sub handle_mime_attachment { #{{{
   my ($part,$file,$defer) = @_;

   my $yep;
   my $spl = 0;
   foreach my $pt (@plaintext_types) {
      #print STDERR "$file> ". $part->{type}. ": $pt\n";
      if ($part->{type} =~ m/^$pt$/i) {
	 if ($part->{type} =~ m,text/html,) {
	    print BROWSER "[ Part " . $part->{'part'} . " - " . 
			   $part->{'desc'} . ", type=" . 
			   $part->{'type'} . " ]<br>\n";
	    $spl = 2;
	 } else {
	    print BROWSER "<br>";
	 }
         browser_print("< $file", $part->{type}, $spl);
	 $yep = 1;
	 last;
      }
   }
   push(@{$defer}, [ $part, $file ]) unless ($yep);
   #print STDERR "\n";

} #}}}

sub mime_for_you { #{{{
   my ($parts,@fileparts) = @_;

   my @justlink;
   foreach (keys(%{$parts})) {
      next unless (defined($parts->{$_}));
      handle_mime_attachment($parts->{$_},$fileparts[$_ - 1],\@justlink);
   }

   # These next files weren't plaintext-printed, so link them.
   if (scalar(@justlink) > 0) {
      print BROWSER "<hr>";
      print BROWSER "Download Attachments:<br>\n";
      foreach (@justlink) {
	 my ($part,$file) = @{$_};
	 print BROWSER "&nbsp;&nbsp;&nbsp;<a href=\"file://$file\">";
	 print BROWSER $part->{'desc'} . " - ";
	 $file =~ s,^.*/,,;
	 print BROWSER "$file (".$part->{'type'}.") [" . $part->{'size'} . "]</a><br>\n";
      }
   }
} #}}}

sub mktemp { #{{{
   my $str;
   
   do {
      $str ="mail.out.";
      for (my $x = 0; $x < 5; $x++) {
	 $str .= int(rand(10));
      }
   } while (-e "/tmp/$str");

   return $str;
} #}}}

sub check_open_browser { #{{{
   if ($VBROWSER !~ m/^[\|>]/) {
      print STERR "Now running browser!\n";
      $BROWSER =~ s/>\s+//;
      if ($VBROWSER =~ /^links/) {
	 system("mv $BROWSER $BROWSER.html");
	 $BROWSER .=".html";
      } 
      system("$VBROWSER $BROWSER");
      system("rm $BROWSER");
   }
} #}}}
