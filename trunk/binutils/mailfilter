#!/usr/bin/perl
# $Id$
#
# Filter mail output from mhl (which should basically be the entire mail)
# 
#  Features:
#    - Automatically open html mail in w3m (see $BROWSER)
#    - Automagically verify pgp signatures
#

use strict;
use MIME::Parser;

# Basic settings {{{
my $TMP = "/u9/psionic/tmp";
my $BROWSER = 'w3m -title -T text/html';
#my $BROWSER = "cat";
my $MHL_PROG = "/usr/local/libexec/nmh/mhl";
my $MHL_HTML_OPTS = "-form mhl.html";
my $MHL_PLAIN_OPTS = "";

# This was stolen from my .muttrc - I'll need to come up with a decent
# parser for these lines eventually.
my %pgp = (
pgp_verify_command => "gpg --no-secmem-warning --quiet --no-verbose --batch --output - --verify %s %f"
	 );
#}}}

# Set $mail, $folder, $base, other useful variables. {{{
my ($mail) = $ARGV[0];
my ($folder) = `folder -fast`; chomp($folder);
my $base;
if ($folder !~ m,^/,) {
   ($base) = `grep '^Path:' $ENV{HOME}/.mh_profile`;
   chomp($base);
   $base =~ s/^Path:\s+(.*)\/?$/$1/;
}
my ($file) = "$base/$folder/$mail";

my $browser_content_type;
#}}}

# Read in the mail headers {{{

my %headers;
my @order;
my ($is_html,$done_headers) = (0,0);
my $header;
my $from_line;

print STDERR "Reading mail headers\n";
open(MAIL, "< $file") or die("Unable to open $file.\n$!\n");

$from_line = <MAIL>; chomp($from_line);

my $boundary;
my $rcv = 0; my $dto = 0;
my $lookforctype = 0;
my @part_types;
while (<MAIL>) {
   chomp();

   if ($done_headers == 0) {
      if (m/^$/) {
	 $done_headers = 1;
	 next;
      }

      if (s/^([A-Za-z-]+):\s+//) {
	 my $a = $1;
	 if ($a eq 'Received') {
	    $a = $a . "_$rcv";
	    $rcv++;
	 } elsif ($a eq 'Delivered-To') {
	    $a = $a . "_$dto";
	    $dto++;
	 }
	 $header = $a;
	 push(@order,$header);
      }
      if (defined($headers{$header})) {
	 $headers{$header} .= "\n" . $_;
      } else {
	 $headers{$header} .= $_;
      }

   } else {
      chomp();
      unless ($boundary) {
	 ($boundary) = grep(/^content-type$/i,keys(%headers)); 
	 $boundary = $headers{$boundary};
	 $boundary =~ m/boundary="([^"]+)"/; $boundary = $1;
      }

      #print $_ . "\n";
      if ($_ eq "--$boundary") {
	 $lookforctype = 1;
	 next;
      }

      if ($lookforctype == 1) {
	 if (m,^Content-Type: ([a-z-]+/[a-z-]+),i) {
	    #print "Part " . (scalar(@part_types) + 1) . ": $1\n";
	    push(@part_types,$1);
	    $lookforctype = 0;
	 }
      }

   }
} # We're done reading the headers }}}

#{{{ Useful Variables (content-typpe, tempfile template, ...)
my ($ctype) = grep(/^content-type$/i,keys(%headers)); 
$ctype = $headers{$ctype};
my $fr = $folder; $fr =~ s,^.*/([^/]+)$,$1,;
my $template = "msg.$fr.$mail";
my $templatereg = '^msg\.'.$fr.'\.'.$mail;
#}}}

if ($ctype =~ m,^multipart/,i) { # handle multipart mail{{{
   print STDERR "Parsing multipart mail ($ctype)\n";
   system("rm $TMP/$template* > /dev/null 2>&1");

   my $parser = new MIME::Parser;
   $parser->output_dir($TMP);
   $parser->filer->output_prefix("$template");
   $parser->parse_in($file);

   #print `ls $TMP/$template*`;
   opendir(DIR,"$TMP");
   my @parts = grep { m,$templatereg, } readdir(DIR);
   closedir(DIR);

   # If part 2 is html, then open it first assuming that this email was dually
   # sent as text/plain and text/html.
   my $mailpart;
   if ( ($parts[1] =~ m/\.html$/ && ($mailpart = $parts[1])) || 
	($parts[0] =~ m/\.html$/ && ($mailpart = $parts[0])) ) {
      my $tmpfile = "$TMP/.headers.$fr.$mail";
      print STDERR "Starting browser\n";

      open(BROWSER, "| $BROWSER");
      browser_set_content_type("text/html");

      mhl_write_headers($tmpfile);
      browser_print("< $tmpfile","text/plain");
      browser_print("< $TMP/$mailpart");

      #open(MAIL, "< $TMP/".$mailpart) or 
	 #die("Failed trying to read $TMP/".$mailpart."\n$!\n");
#
      #while (<MAIL>) {
	 #print BROWSER $_;
      #}
      #close(MAIL);
      
      close(BROWSER);

      system("rm $tmpfile");
   } else {
      # This doesn't appear to be an html mail, let's deduce what it is...

      if (scalar(grep(/application\/pgp-signature/,@part_types)) > 0) {
	 # This is pgp signed mail.
	 my ($plain, $sig, $plaintype);
	 my $count = 0;
	 foreach my $part (@parts) {
	    my $type = $part_types[$count];
	    if ($type =~ m,text/(plain|html),) {
	       $plain = $part;
	       $plaintype = $type;
	    }
	    $sig = $part if ($type eq 'application/pgp-signature');
	    $count++;
	 }
	 print "Plain: $plain\n";
	 print "sig: $sig\n";

	 #print "text/plain part: $plain\n";
	 #print "pgp-sig part: $sig\n";
	 my $pgp_verify = $pgp{'pgp_verify_command'};
	 $pgp_verify =~ s,%s,$TMP/$sig,;
	 $pgp_verify =~ s,%f,$TMP/$plain,;

         print STDERR "Starting browser...\n";
	 open(BROWSER, "| $BROWSER");
	 browser_set_content_type("text/html");
	 #open(BROWSER, "> /dev/null");

	 my $tmpfile = "$TMP/.headers.$fr.$mail";

	 mhl_write_headers($tmpfile);
	 browser_print($tmpfile,"text/html");
	 browser_print("$pgp_verify 2>&1 |", "text/plain",1);
         browser_print("$TMP/$plain","$plaintype");

	 #open(MAIL, "< $TMP/".$plain) or 
	    #die("Failed trying to read $TMP/".$plain."\n$!\n");

	 #while (<MAIL>) {
	    #print BROWSER $_;
	    #print BROWSER "<br>" if ($plaintype eq 'text/plain');
	 #}
	 #close(MAIL);

	 close(BROWSER);

	 #system("$MHL_PROG $MHL_PLAIN_OPTS $mail | " . $ENV{'PAGER'});
      } else {
	 my $UNKNOWN_FORMAT = "*** Unknown Mail footprint!!!\n*** Could not figure out what kind of mail this is.\n*** Number of parts: " . scalar(@parts) . "\n*** Content-Type: $ctype\n";
	 system("(echo '$UNKNOWN_FORMAT' && $MHL_PROG $MHL_PLAIN_OPTS $mail) | " . $ENV{'PAGER'});
      }

   }

   foreach (@parts) {
      #system("rm $TMP/$_");
   }
#}}}
} else { # {{{ Not multipart mail.

   if ($ctype =~ m,^text/html,) {
      print "Starting browser...\n";
      system("$MHL_PROG $MHL_HTML_OPTS $mail | $BROWSER");
   } elsif ($ctype =~ m,^text/plain,) {
      print "Starting browser...\n";
      system("$MHL_PROG $MHL_PLAIN_OPTS $mail | " . $ENV{'PAGER'});
   } else {
      print "Mail content type: " . $ctype . "\n";
      print "I don't know how to handle this!\n";
   }
} # }}}

sub mhl_write_headers { #{{{
   my ($tmpfile) = shift;

   open(MHLWRITE, "| $MHL_PROG $MHL_HTML_OPTS > $tmpfile") or
      die("Failed trying to pipe to $MHL_PROG\n$!\n"); 

   print MHLWRITE "$from_line\n";
   foreach (@order) {
      my $a = $_;
      $a =~ s/^(Received|Delivered-To)_[0-9]+$/(Received|Delivered-To)/;

      print MHLWRITE "$a:  $headers{$_}\n";
   }
   close(MHLWRITE);
} #}}}

sub browser_print { #{{{
   my ($what,$type,$splitter) = @_;
   my $contents;

   if (ref($what) eq 'GLOB') {
      $contents = $what;
   } else {
      open($contents,"$what") 
	 or die("Unable to open $what for reading.\n> $!\n");
   }

   my $not_real_html = 0;
   if ( ($browser_content_type eq 'text/html') && 
	($browser_content_type ne $type) ) {
      $not_real_html = 1;
   }
			
   while (<$contents>) { 
      if ($not_real_html) {
	 s/</&lt;/g; s/>/&gt;/g;
         print BROWSER $_ . "<br>";
      } else {
	 print BROWSER $_;
      }
   }

   print BROWSER "<hr>" if ($splitter);



   close($contents) if (ref($what) ne 'GLOB');
} #}}}

sub browser_set_content_type { #{{{
   my $type = shift;

   $browser_content_type = $type;
} #}}}
