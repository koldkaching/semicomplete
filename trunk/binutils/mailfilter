#!/usr/bin/perl
# $Id$
#
# Filter mail output from mhl (which should basically be the entire mail)
# 
#  Features:
#    - Automatically open html mail in w3m (see $BROWSER)
#    - Automagically verify pgp signatures
#

use strict;
#use MIME::Parser;
#MIME::Parser sucks, mhstore rocks.

# Basic settings {{{
my $TMP = "/u9/psionic/tmp";
my $BROWSER = 'w3m -title -T text/html';
#my $BROWSER = "cat";
my $MHL_PROG = "/usr/local/libexec/nmh/mhl";
my $MHL_HTML_OPTS = "-form mhl.html";
my $MHL_PLAIN_OPTS = "-form mhl.plaintext";

# This was stolen from my .muttrc - I'll need to come up with a decent
# parser for these lines eventually.
my %pgp = (
pgp_verify_command => "gpg --no-secmem-warning --quiet --no-verbose --batch --output - --verify %s %f"
	 );
#}}}

# Plain-text types to be displayed normally without filtration:
my @plaintext_types = ( 
   'text/.*', 'message/delivery-status' 
   );

# Set $mail, $folder, $base, other useful variables. {{{
my ($mail) = $ARGV[0];
my ($folder) = `folder -fast`; chomp($folder);
my $base;
if ($folder !~ m,^/,) {
   ($base) = `grep '^Path:' $ENV{HOME}/.mh_profile`;
   chomp($base);
   $base =~ s/^Path:\s+(.*)\/?$/$1/;
}
my ($file) = "$base/$folder/$mail";

my $browser_content_type;
#}}}

# Read in the mail headers {{{

my %headers;
my @order;
my ($is_html,$done_headers) = (0,0);
my $header;
my $from_line;

print STDERR "Reading mail headers\n";
open(MAIL, "< $file") or die("Unable to open $file.\n$!\n");

$from_line = <MAIL>; chomp($from_line);

my $boundary;
my %ticks;
my $lookforctype = 0;
my @part_types;
while (<MAIL>) {
   chomp();

   if ($done_headers == 0) {
      if (m/^$/) {
	 $done_headers = 1;
	 next;
      }

      if (s/^([A-Za-z-]+):\s+//) {
	 my $a = $1;
	 unless ($a =~ m/^Content-Type$/i) {
	    $ticks{$1}++;
	    $a .= "_" . $ticks{$1};
	 }

	 $header = $a;
	 push(@order,$header);
      }
      if (defined($headers{$header})) {
	 $headers{$header} .= "\n" . $_;
      } else {
	 $headers{$header} .= $_;
      }

   } else {
      chomp();
      unless ($boundary) {
	 ($boundary) = grep(/^content-type$/i,keys(%headers)); 
	 $boundary = $headers{$boundary};
	 $boundary =~ m/boundary="([^"]+)"/; $boundary = $1;
      }

      #print $_ . "\n";
      if ($_ eq "--$boundary") {
	 $lookforctype = 1;
	 next;
      }

      if ($lookforctype == 1) {
	 if (m,^Content-Type: ([a-z-]+/[a-z-]+),i) {
	    #print "Part " . (scalar(@part_types) + 1) . ": $1\n";
	    push(@part_types,$1);
	    $lookforctype = 0;
	 }
      }

   }
} 
close(MAIL);
# We're done reading the headers }}}

#{{{ Useful Variables (content-typpe, tempfile template, ...)
my ($ctype) = grep(/^content-type$/i,keys(%headers)); 
$ctype = $headers{$ctype};
my $fr = $folder; $fr =~ s,^.*/([^/]+)$,$1,;
my $template = "$mail";
my $templatereg = '^'.$mail.'\.[0-9]+\.';
#}}}

if ($ctype =~ m,^multipart/,i) { # handle multipart mail{{{
   print STDERR "Parsing multipart mail ($ctype)\n";
   system("rm $TMP/$template* > /dev/null 2>&1");

   my %parts;

   my $partlist = `mhlist -noheaders`;
   foreach (split("\n",$partlist)) {
      next if (m,multipart,i);
      chomp(); s/^\s+//;
      my ($part,$type,$size,$desc) = split(/\s+/,$_,4);
      $parts{$part} = { 'type' => $type, 'size' => $size, 
                        'desc' => $desc, 'part' => $part };
      #print "Parts: " . $parts{$part} . "\n";
      system("mhstore -part $part > /dev/null 2>&1");
   }

   #system("mhstore");

   #print `ls $TMP/$template*`;
   opendir(DIR,"$TMP");
   my @fileparts = grep { m,$templatereg, } readdir(DIR);
   closedir(DIR);

   #print "Files: " . join(" | ", @fileparts) . "\n";

   # If part 2 is html, then open it first assuming that this email was dually
   # sent as text/plain and text/html.
   my $mailpart;
   if ( ($parts{2}{type} =~ m/\.html$/ && ($mailpart = $parts{2})) || 
	($parts{1}{type} =~ m/\.html$/ && ($mailpart = $parts{1})) ) {
      my $tmpfile = "$TMP/.headers.$fr.$mail";
      print STDERR "Starting browser\n";

      open(BROWSER, "| $BROWSER");
      browser_set_content_type("text/html");

      mhl_write_headers($tmpfile);
      browser_print("< $tmpfile","text/plain");
      browser_print("< $TMP/$mailpart");

      close(BROWSER);

      #system("rm $tmpfile");
   } else {
      # This doesn't appear to be an html mail, let's deduce what it is...

      print STDERR "Starting browser...\n";
      open(BROWSER, "| $BROWSER");
      #open(BROWSER, "> /dev/null");
      browser_set_content_type("text/html");
      my $tmpfile = "$TMP/.headers.$fr.$mail";
      mhl_write_headers($tmpfile);
      browser_print($tmpfile,"text/html");

      # Do PGP stuff first?
      if (scalar(grep(/application\/pgp-signature/,@part_types)) > 0) { 
	 # pgp-signed email {{{
	 print STDERR "pgp signature found, invoking pgp... ";
	 my ($plain, $sig, $plaintype);
	 my ($pidx, $sidx);
	 my $count = 0;
	 foreach my $part (@fileparts) {
	    my $type = $part_types[$count];
	    if ( (!defined($plain)) && ($type =~ m,text/(plain|html),) ) {
	       $plain = $part;
	       $plaintype = $type;
	       $pidx = $count;
	    }
	    if ( (!defined($sig)) && ($type eq 'application/pgp-signature') ) {
	       $sig = $part;
	       $sidx = $count;
	    } 
	    $count++;
	 }
	 #print "Plain: $plain\n";
	 #print "sig: $sig\n";

	 #print "text/plain part: $plain\n";
	 #print "pgp-sig part: $sig\n";
	 my $pgp_verify = $pgp{'pgp_verify_command'};
	 $pgp_verify =~ s,%s,$TMP/$sig,;
	 $pgp_verify =~ s,%f,$TMP/$plain,;

	 browser_print("$pgp_verify 2>&1 |", "text/plain",1);
         #browser_print("$TMP/$plain","$plaintype");

	 undef($parts{$sidx});
	 print STDERR "done.\n"

	 #}}}
      }

      browser_print("< $TMP/" . $fileparts[0], $parts{1}{'type'}, 1);

      undef($parts{1});

      mime_for_you(\%parts,@fileparts);

      close(BROWSER);
      system("rm $tmpfile");
   }

   foreach (@fileparts) {
      system("rm $TMP/$_");
   }
#}}}
} else { # {{{ Not multipart mail.

   print "Starting browser...\n";
   open(BROWSER,"| $BROWSER") or die(":( $!");
   browser_print("$MHL_PROG $MHL_PLAIN_OPTS $mail |","$ctype");
   close(BROWSER);

} # }}}

sub mhl_write_headers { #{{{
   my ($out) = shift;

   open(MHLWRITE, "| $MHL_PROG $MHL_HTML_OPTS > $out") or
      die("Failed trying to pipe to $MHL_PROG\n$!\n"); 

   print MHLWRITE "$from_line\n";
   foreach (@order) {
      my $a = $_;
      $a =~ s/^([A-Za-z-]+)_[0-9]+$/\1/;

      print MHLWRITE "$a:  $headers{$_}\n";
   }
   close(MHLWRITE);
} #}}}

sub browser_print { #{{{
   my ($what,$type,$splitter) = @_;
   my $contents;

   if (ref($what) eq 'GLOB') {
      $contents = $what;
   } else {
      open($contents,$what) 
	 or die("Unable to open $what for reading.\nreason> $!\n");
   }

   my $not_real_html = 0;
   if ( ($browser_content_type eq 'text/html') && 
	($browser_content_type ne $type) ) {
      $not_real_html = 1;
   }
			
   while (<$contents>) { 
      if ($not_real_html) {
	 s/</&lt;/g; s/>/&gt;/g;
         print BROWSER $_ . "<br>";
      } else {
	 print BROWSER $_;
      }
   }

   print BROWSER "<hr>" if ($splitter);

   close($contents) if (ref($what) ne 'GLOB');
} #}}}

sub browser_set_content_type { #{{{
   my $type = shift;

   $browser_content_type = $type;
} #}}}

sub handle_mime_attachment { #{{{
   my ($part,$file,$defer) = @_;

   my $yep;
   foreach (@plaintext_types) {
      if ($part->{type} =~ m/$_/i) {
	 print BROWSER "[ Part " . $part->{'part'} . " - " . 
	                $part->{'desc'} . ", type=" . 
			$part->{'type'} . " ]<br>\n";

         browser_print("< $TMP/$file", $part->{type}, 1);
	 $yep = 1;
	 last;
      }
   }
   push(@{$defer}, [ $part, $file ]) unless ($yep);

} #}}}

sub mime_for_you {
   my ($parts,@fileparts) = @_;

   my @justlink;
   foreach (keys(%{$parts})) {
      next unless (defined($parts->{$_}));
      handle_mime_attachment($parts->{$_},$fileparts[$_ - 1],\@justlink);
   }

   # These next files weren't plaintext-printed, so link them.
   if (scalar(@justlink) > 0) {
      print BROWSER "Download Attachments:<br>\n";
      foreach (@justlink) {
	 my ($part,$file) = @{$_};
	 print BROWSER "&nbsp;&nbsp;&nbsp;<a href=\"file://$TMP/$file\">";
	 print BROWSER $part->{'desc'} . " - ";
	 print BROWSER "$file (".$part->{'type'}.")</a><br>\n";
      }
   }
}


