#!/usr/bin/perl
# Grok is released under the Creative Commons Attribution 2.5 License
# If you care, an overview of this license (and the legalese) is at:
# http://creativecommons.org/licenses/by/2.5/
#
# Email jls@csh.rit.edu if you have any problems or questions with using Grok!

use strict;
use warnings;
use Data::Dumper;
use IO::Select;
use Getopt::Std;
use POSIX qw(setsid);
use Memoize;

# For older versions of perl.. but do I really care that much?
use Symbol;

# allow (?{ code }) assertions in dynamically generated regexen.
# This let's me do named captures with $^N
use re 'eval';

# Things you'll need to have installed (from CPAN):
use Regexp::Common qw(RE_ALL);
use Parse::RecDescent;
use Date::Parse;
use Unix::Syslog qw(:macros :subs);

# Memoization of pattern2regex increases speed by a factor of 2.5
memoize('pattern2regex');

my @logrefs;
my $debuglevel = 0;

my $PATTERNS;
	
# Pattern-space wildcards, used as %WILDCARD% in the pattern config
my %MATCH = (
	USERNAME => qr/\w+/,
	USER => qr/\w+/,
	IP => $RE{net}{IPv4},
	PORT => qr/\d+/,
	COUNT => qr/\d+/,
	HOSTNAME => qr/(?! )$RE{net}{domain}/,

	# Months: January, Feb, 3, 03, 12, December
	MONTH => qr/(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?|0?[0-9]|1[0-2])/,
	MONTHDAY => qr/(?:[0-2]?[0-9])|3[01]/,

	# Days: Monday, Tue, Thu, 0 (Sunday?), 6 (Saturday?)
	DAY => qr/(?:Mon(?:day)?|Tue(?:sday)?|Wed(?:nesday)?|Thu(?:rsday)?|Fri(?:day)?|Sat(?:urday)?|Sun(?:day)?|[0-6])/,

	# Time: HH:MM:SS
	TIME => qr/\d{2}:\d{2}:\d{2}/,

	# Syslog Dates: Month Day HH:MM:SS
	SYSLOGDATE => "%MONTH% +%MONTHDAY% %TIME%",

	QUOTEDSTRING => $RE{quoted},
);

# Dispatch table for filter chains.
# shnq - escaping for use in non-quoted shell context
# shdq - escaping for use in double-quoted shell strings
# e[XYZ] - generic escaping, will escape the characters inside the brackets.
# stripquotes - strip leading and trailing quotes.
# parsedate - convert time values
my $filters = {
	qr/shnq/ => sub { s/([`(){}[\]\$*?!|;'"])/\\$1/g; },
	qr/shdq/ => sub { s/([`\$"])/\\$1/g; },
	qr/e\[((?:(?:\\])|(?:[^\]]))+)\]/ => sub { s/([$1])/\\$1/g; },
	qr/stripquotes/ => sub { s/^(["])//; s/$1$//; },
	qr/parsedate/ => sub { str2time($_) },
};

my $opts = {};
getopt('fdb', $opts);

if (exists($opts->{"d"})) {
	# default to debuglevel 1 if -d has no arguments.
	$debuglevel = $opts->{"d"} || 1;
	debug(1, "Debug level: $debuglevel");
}

if (exists($opts->{"b"})) {
	print STDERR "Going to background...\n";
	exit if (fork() != 0); # Kill the parent

	# Break away from the terminal, if any.
	die "Cannot detach from terminal (setsid failed)" unless POSIX::setsid();
	#chdir("/");
	umask(0);

	# Redirect stdin/stdout/stderr to /dev/null
	map { close($_) } (\*STDIN,\*STDOUT,\*STDERR);
	open(STDIN, "+>/dev/null");
	open(STDOUT, "+>&STDIN");
	open(STDERR, "+>&STDIN");

	# Change ps output to something reasonable?
	#$0 = "grok " . join(" ",@ARGV);
}

# Syslog to stderr, too, if we aren't going to the background.
my $logopts = LOG_PID;
openlog("grok", $logopts, LOG_USER);

my $config = readconfig($opts->{"f"});
#print Dumper($config);
unless (defined($config)) {
	debug(0, "Syntax error in config?");
	exit(1);
}
setup($config);

my $state;
my $storage; # Match-level storage by File/Key
my $select = IO::Select->new();

foreach (keys(%$config)) {
	next if ($_ eq "patterns");
	my $s = Symbol::gensym;
	my $command = $_;

	# Run 'file' types as 'tail -0 -f [file]'
	$command = "tail -0f '$_'" if ($config->{$_}->{"type"} eq 'file');

	debug(2, "Startup: Running $command");
	open($s, "$command |") or die($!);
	$select->add($s);
	$state->{"map"}->{$s} = $_;
}

# Loop for data for as long as our love shall last...
while($select->count()) {
	my @ready = $select->can_read(60);
	map(readlog($_), @ready);
}

debug(0, "Nothing left to do (all files/execs ended) exiting");
exit(0);

sub debug {
	my ($level, $msg) = @_;
	$msg =~ s/[^\n]$/$&\n/s; # Add a newline if there isn't one.
	if ($level <= $debuglevel) {
		printf STDERR ("%s: [debug%d] %s", $0, $level, $msg);
		syslog(LOG_INFO, "%s", $msg);
	}
}

sub readlog {
	my $logh = shift;
	my $buffer = $state->{"buffers"}->{$logh} || "";
	my $bytes = sysread($logh, $buffer, 1024, length($buffer));
	if ($bytes == 0) {
		debug(0,"finished (possibly unexpected eof?): " . $state->{"map"}->{$logh});
		$select->remove($logh);
		close($logh);
	}
	while ($buffer =~ s!(.*)\n!!) {
		#print $state->{"map"}->{$logh} . "> $1\n";
		handle($state->{"map"}->{$logh},$1);
	}
	$state->{"buffers"}->{$logh} = $buffer;
}

sub handle {
	my ($log,$line,$syslogmode) = @_;
	chomp($line);
	my $matched = 0;
	#print $log . "> " . $line;

	$storage->{$log} = {} if (!exists($storage->{$log}));

	my $last = { line => $line };

	#debug(0, "Syslog: ($log) ".$config->{$log}->{"syslog"});

	if ($config->{$log}->{"syslog"}) {
		# Syslog repetition message looks like this:
		# last message repeated N times
		if ($line =~ m/last message repeated (\d+) times$/) {
			my $c = $1;
			my $lastline = $state->{"last"}->{$log};
			if (defined($lastline)) {
				handle($log, $lastline, 1) while ($c-- > 0);
			} else {
				debug(1, "Cannot repeat 'last' line $c times becuase I haven't seen the previous line. ($log)");
			}
		}
	}

	my $patterns = $PATTERNS->{$log};
	foreach my $pattern (keys(%{$patterns})) {
		# "fix" the line, turn it into a regex.
		my $regex = pattern2regex($pattern);

		# The regex match will store keys in this hash
		# XXX: This used to work with 'my' instead of 'our' - I'm not sure why.
		our %values = ();
		debug(5, "Line: $line");
		debug(5, "Regex: $regex");
		debug(5, "Is Match: " . ($line =~ m/$regex/));
		if ($line =~ m/($regex)/) {
			$matched++;

			# Set some other magic entries to %values
			$values{'=LINE'} = $line;
			$values{'=MATCH'} = $1;

			# Handle if we're over the threshold
			my $pat = $PATTERNS->{$log}->{$pattern};
			my $fileconf = $config->{$log}->{"types"}->{$pat};
			my $keyname;

			$keyname = $pat . "::" . meta2string($fileconf->{"key"}, \%values) if (exists($fileconf->{"key"}));
			$keyname ||= join (",", $pat, map { "$_=>$values{$_}" } keys(%values));

			debug(3, "UniqueKey: $keyname");
			$state->{$keyname}->{"time"} ||= time();
			$state->{$keyname}->{"count"}++;

			if ($state->{$keyname}->{"count"} >= $fileconf->{"threshold"})  {
				if ($fileconf->{"interval"} == 0
					 || ((time() - $state->{$keyname}->{"time"}) <= $fileconf->{"interval"})) {
					debug(2, "Limits (threshold/interval) exceeded for rulekey: $keyname");
					react($fileconf, \%values, $log, $keyname);
				} else { 
					$state->{$keyname}->{"time"} = time();
				}
				$state->{$keyname}->{"count"} = 0;
			}
			$last->{"values"} = \%values;
			$last->{"handler"} = $PATTERNS->{$log}->{$pattern};
		}
	}

	# If we haven't matched this line yet, call the 'unmatched' handler?
	if ($matched == 0) {
		my $fileconf = $config->{$log}->{"unmatched"};
		react($fileconf, { "=LINE" => $line }, $log, "unmatched") if (defined($fileconf));
	}

	$state->{"last"}->{$log} = $last unless ($syslogmode);
}

sub pattern2regex {
	my $pattern = shift;
	my $regex = $pattern;
	my $orig = $pattern;

	my $count;
	do {
		my $rounds = 0;
		$count = 0;
		# Replace %KEY:SUBNAME% with a regex and store the capture as KEY:SUBNAME
		# The :SUBNAME specification is optional, 
		# ie; %IP% is valid, as is %IP:FOO%
		map { $count += $regex =~ s/%(($_)(?::\w+)?)%/($MATCH{$_})(?{ \$values{'$1'} = \$^N })/g; } keys(%MATCH);
		$rounds++;
		if ($rounds > 10) {
			debug(0, "Deep recursion translating '$orig'");
			last;
		}
	} while ($count > 0);

	return $regex;
}

sub meta2string {
	my $meta = shift;
	my $values = shift;
	my $orig = $meta;

	my $rounds = 0;
	my $count;
	do {
		$count = 0;
		#map { $count += $meta =~ s/%($_)%/$values->{$_}/g; } keys(%MATCH);

		# XXX: This will be undef if the key in $values is null, should that ever happen?
		map {
			my $regex = qr/%(\Q$_\E(?::\w+)?)(?:\|((?:\S+)(?:,\S+)*))?%/;
			while ($meta =~ m/$regex/) {
				$count++;
				my $data = filter($values, $1, $2);
				$meta =~ s/$regex/$data/;
			}
		} (keys(%MATCH), '=LINE', '=MATCH');
		$rounds++;
		if ($rounds > 10) {
			debug(0, "Deep recursion translating '$orig'");
			last;
		}
	} while ($count > 0);

	return $meta;
}

# XXX: There may be some performance issues in this function
sub filter {
	my ($values, $key, $opts) = @_;
	my $ret = $values->{$key};
	$opts = "" unless (defined($opts));

	# Wrapper function to call a dispatch function and set $_
	local *w = sub { 
		debug(0, "No filter matches $_[0]") and return unless defined($filters->{$_[0]});
		local $_ = $_[1];
		$filters->{$_[0]}->($_[1]);
		return $_;
	};

	# Apply filters in sequence until we run out of filters to apply.
	my $re = join("|", map { qr/(?:$_)/ } keys(%$filters));
	while ($opts =~ s/^$re//) {
		my ($key) = grep { $& =~ m/$_/ } keys(%$filters);
		$ret = w($key, $ret);
		last unless $opts =~ s/^\|//;
	}

	return $ret;
}

sub readconfig {
	my $cfname = shift || "grok.conf";
	debug(2, "Reading from $cfname");
	my $grammar = << 'GRAMMAR';
config: <rulevar: local $config = { }>
config: (file | pattern | filter | ignorable )(s) /\Z/ { $return = $config }
ignorable: (comment | blankline)(s)
comment: /#[^\n]*/
blankline: /^\s*\n/

#error: /^[^\Z\n]/ { main::debug(0, "Error on line: $thisline ? (missing a semicolon perhaps?)"); }

string: /((?:\")(?:[^\\\"]*(?:\\.[^\\\"]*)*)(?:\")|(?:\')(?:[^\\\']*(?:\\.[^\\\']*)*)(?:\')|(?:\`)(?:[^\\\`]*(?:\\.[^\\\`]*)*)(?:\`))/ { $return = substr($item[1],1,-1) }
#string: <perl_quotelike> { $return = $item[1]->[2] }
number: /\d+/
word: /\w+/
perlblock: <perl_codeblock>

pattern: <rulevar: local $pattern = { }>
pattern: 'patterns' '{' (pattern_entry)(s) '}' ';' { main::addpatterns($pattern) }
pattern_entry: pattern_name '=' pattern_string ';' { $pattern->{$item[1]} = $item[3] }
pattern_name: word
pattern_string: string

filter: <rulevar: local $filter = { }>
filter: 'filters' '{' (filter_entry | ignorable)(s?) '}' ';' { main::addfilters($filter) }
filter_entry: filter_name '=' filter_string ';' { $filter->{$item[1]} = $item[3] }
filter_name: <perl_quotelike> { $return = $item[1]->[2] }
filter_string: perlblock

file: <rulevar: local $file = { }>
file: filespec filename '{' file_entry(?) '}' ';' { $config->{$item[2]} = $file }
filespec: ('file' | 'exec') { $file->{'type'} = $item[1] }
filename: string
file_entry: (file_entry_line | ignorable)(s)
file_entry_line: (syslog | type | unmatched) ';'

syslog: 'syslog' '=' number { $file->{"syslog"} = $item[3] }

type: <rulevar: local $type = { }>
type: 'type' typename '{' type_entry '}' { $file->{"types"}->{$item[2]} = $type }
typename: string
type_entry: (((match | threshold | interval | reaction | key) ';') | ignorable)(s)

match: 'match' '=' string { push(@{$type->{"matches"}},$item[3]) }
threshold: 'threshold' '=' number { $type->{"threshold"} = $item[3] }
interval: 'interval' '=' number { $type->{"interval"} = $item[3] }
key: 'key' '=' string { $type->{"key"} = $item[3] }
reaction: 'reaction' '=' reactionspec { push(@{$type->{"reactions"}}, $item[3]) }
reactionspec: string { $return = { type => "command", string => $item[1] } } 
				  | perlblock {
						my $func = 'package main; $func = sub ' . $item[1];
						$func =~ s/{/{ my (\$d,\$v,\$s) = \@_;/;
						eval($func);
						print STDERR "PERL SYNTAX ERROR IN CONFIG:\n$@\n" if $@;
						$return = { type => "perl", string => $func } 
					}

unmatched: <rulevar: local $type = { }>
unmatched: 'unmatched' '{' (reaction ';')(s?) '}' { $file->{"unmatched"} = $type }
GRAMMAR

	my $parser = Parse::RecDescent->new($grammar);
	my $config;
	local $/ = undef;
	open(CONFIG, $cfname) or die("Unable to open: $cfname");
	$config = $parser->config(<CONFIG>);
	close(CONFIG);

	return $config;
}

sub setup {
	my $config = shift;
	debug(1, "Watching: " . join(", ", keys(%$config)));
	foreach my $file (keys(%{$config})) {
		my $matches = $config->{$file}->{"types"};
		my $matchhash;
		foreach my $match (keys(%{$matches})) {
			debug(2, "Match: $match");
			foreach my $string (@{$matches->{$match}->{"matches"}}) {
				debug(2, "String: $string");
				$matchhash->{$string} = $match;
			}
			$matches->{$match}->{"interval"} ||= 0;
			$matches->{$match}->{"threshold"} ||= 0;

			# Normalize perl blocks ?
			map {
				if ($_->{"type"} eq 'perl') {
					#$_->{"string"} =~ s/^\s*{\s*(.*)\s*}\s*$/$1/;
					#"Perl: " . $_->{"string"} . "\n";
				}
			} @{$matches->{$match}->{"reactions"}};
				
		}
		$PATTERNS->{$file} = $matchhash;
	}
}

sub addpatterns {
	my $p = shift;
	foreach my $pattern (keys(%$p)) {
		debug(2, "Adding pattern '$pattern'");
		$MATCH{$pattern} = $p->{$pattern};
	}
	return 0;
}

sub addfilters {
	my $f = shift;
	print STDERR Dumper($f);
	foreach my $filter (keys(%$f)) {
		debug(2, "Adding filter '$filter': " . $f->{$filter});
		# Sanitize filter:
		my $sf = $filter;
		$sf  =~ s/^{|}$//g;
		$sf = qr/$sf/;
		$filters->{$sf} = sub { eval($f->{$filter}); }
	}

	return 0;
}

sub react {
	my ($fileconf, $values, $log, $keyname) = @_;
	foreach (@{$fileconf->{"reactions"}}) {
		my ($cmd,$type) = ($_->{"string"}, $_->{"type"});
		if ($type eq 'command') {
			$cmd = meta2string($cmd, $values);
			debug(1, "Executing (from $keyname): $cmd");
			system($cmd);
		} elsif ($type eq 'perl') {
			my ($d, $v, $s);
			# XXX: Should this just be $foo ||= {} ?
			$storage->{$log}->{$keyname} = {} if (!exists($storage->{$log}->{$keyname}));
			$d = $storage->{$log}->{$keyname};
			map { $s->{$_} = $fileconf->{$_} } qw(threshold count interval);
			$v = $values;
			# XXX: Instead of always evalling this, why not create a
			# subroutine like so: my $func; eval('$func = sub { $cmd }')
			# and always call $func->() instead?
			#eval($cmd);
			#print $cmd;
			$cmd->($d,$v,$s);
			warn $@ if $@;
		} else {
			debug(0, sprintf("Unknown execution type: %s. %s", $type, $cmd));
		}
	}
}
