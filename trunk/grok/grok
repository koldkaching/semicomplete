#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;
use IO::Select;
use Getopt::Std;
use POSIX qw(setsid);
use Memoize;

# For older versions of perl
use Symbol;

# pragma - allow (?{ code }) assertions in dynamically generated regexen.
# This let's me do named captures with $^N
use re 'eval';

# Things you'll need to have installed (from CPAN):
use Regexp::Common qw(RE_ALL);
use Parse::RecDescent;
use Unix::Syslog qw(:macros :subs);

# Memoization of pattern2regex increases speed by a factor of 2.5
memoize('pattern2regex');

my @logrefs;
my $debuglevel = 0;


my $PATTERNS;
	
# Pattern-space wildcards, used as %WILDCARD% in the pattern config
my %MATCH = (
	USERNAME => qr/\w+/,
	USER => qr/\w+/,
	IP => $RE{net}{IPv4},
	PORT => qr/\d+/,
	COUNT => qr/\d+/,
);

my $opts = {};
getopt('fdb', $opts);

if (exists($opts->{"d"})) {
	# default to debuglevel 1 if -d has no arguments.
	$debuglevel = $opts->{"d"} || 1;
	debug(1, "Debug level: $debuglevel");
}

if (exists($opts->{"b"})) {
	print STDERR "Going to background...\n";
	exit if (fork() != 0);

	# Break away from the terminal, if any.
	print "setsid: " . POSIX::setsid() . "\n";
	#chdir("/");
	umask(0);

	
	# Redirect stdin/stdout/stderr to /dev/null
	map { close($_) } (\*STDIN,\*STDOUT,\*STDERR);
	open(STDIN, "+>/dev/null");
	open(STDOUT, "+>&STDIN");
	open(STDERR, "+>&STDIN");

	# Change ps output to something reasonable?
	#$0 = "logwatcher " . join(" ",@ARGV);
}

# Syslog to stderr, too, if we aren't going to the background.
my $logopts = ((!exists($opts->{'b'})) ? LOG_PERROR : 0) | LOG_PID;
openlog("logwatcher", $logopts, LOG_USER);

my $config = readconfig($opts->{"f"});
#print Dumper($config);
unless (defined($config)) {
	debug(0, "Syntax error in config?");
	exit(1);
}
setup($config);

my $state;
my $storage; # Match-level storage by File/Key
my $select = IO::Select->new();

foreach (keys(%$config)) {
	next if ($_ eq "patterns");
	my $s = Symbol::gensym;
	my $command = $_;
	if ($config->{$_}->{"type"} eq 'file') {
		$command = "tail -0 -f $_";
	}
	debug(2, "Startup: Running $command");
	open($s, "$command |") or die($!);
	$select->add($s);
	$state->{"map"}->{$s} = $_;
}

# Loop for data for as long as our love shall last...
while(1) {
	last if ($select->count() == 0);
	my @ready = $select->can_read(60);
	map(readlog($_), @ready);

	# XXX: Perhaps perform time-based checks here?
	# Allow periodic statistics reporting to be sent off via email?
	# XXX(2): Nah, Go the UNIX route. Provide logwatch-record and logwatch-summarize
	#   or something...

}

debug(0, "Nothing left to do (all files/execs ended) exiting");
exit(0);

sub debug {
	my ($level, $msg) = @_;
	$msg =~ s/[^\n]$/$&\n/s; # Add a newline if there isn't one.
	if ($level <= $debuglevel) {
		#printf STDOUT ("%s: [debug%d] %s", $0, $level, $msg) if ($level <= $debuglevel);
		syslog(LOG_INFO, "%s", $msg);
	}
}

sub readlog {
	my $logh = shift;
	my $buffer = $state->{"buffers"}->{$logh} || "";
	my $bytes = sysread($logh, $buffer, 1024, length($buffer));
	if ($bytes == 0) {
		debug(0,"finished (possibly unexpected eof?): " . $state->{"map"}->{$logh});
		$select->remove($logh);
		close($logh);
	}
	while ($buffer =~ s!(.*)\n!!) {
		#print $state->{"map"}->{$logh} . "> $1\n";
		handle($state->{"map"}->{$logh},$1);
	}
	$state->{"buffers"}->{$logh} = $buffer;
}

sub handle {
	my ($log,$line,$syslogmode) = @_;
	chomp($line);
	#print $log . "> " . $line;

	$storage->{$log} = {} if (!exists($storage->{$log}));

	my $last = { line => $line };

	#debug(0, "Syslog: ($log) ".$config->{$log}->{"syslog"});

	if ($config->{$log}->{"syslog"}) {
		# Syslog repetition message looks like this:
		# last message repeated N times
		if ($line =~ m/last message repeated (\d+) times$/) {
			my $c = $1;
			my $lastline = $state->{"last"}->{$log};
			if (defined($lastline)) {
				handle($log, $lastline, 1) while ($c-- > 0);
			} else {
				debug(1, "Cannot repeat 'last' line $c times becuase I haven't seen the previous line. ($log)");
			}
		}
	}

	my $patterns = $PATTERNS->{$log};
	foreach my $pattern (keys(%{$patterns})) {
		# "fix" the line, turn it into a regex.
		my $regex = pattern2regex($pattern);
		# The regex match will store keys in this hash

		# XXX: This used to work with 'my' instead of 'our' - I'm not sure why.
		our %values = ();
		debug(5, "Line: $line");
		debug(5, "Regex: $regex");
		debug(5, "Match: " . ($line =~ m/$regex/));
		if ($line =~ m/($regex)/) {

			# Set some other magic entries to %values
			$values{'=LINE'} = $line;
			$values{'=MATCH'} = $1;
			map { debug(0, "Key: $_") } keys(%values);
			#print "Line: $line\n";

			# Handle if we're over the threshold
			my $pat = $PATTERNS->{$log}->{$pattern};
			my $fileconf = $config->{$log}->{"types"}->{$pat};
			my $keyname;

			$keyname = $pat . "::" . meta2string($fileconf->{"key"}, \%values) if (exists($fileconf->{"key"}));
			$keyname ||= join (",", $pat, map { "$_=>$values{$_}" } keys(%values));

			debug(2, "UniqueKey: $keyname");
			$state->{$keyname}->{"time"} ||= time();
			$state->{$keyname}->{"count"}++;

			if ($state->{$keyname}->{"count"} >= $fileconf->{"threshold"})  {
				if ($fileconf->{"interval"} == 0 
					 || ((time() - $state->{$keyname}->{"time"}) <= $fileconf->{"interval"})) { 
					debug(2, "Limits (threshold/interval) exceeded for rulekey: $keyname");
					map {
						my ($cmd,$type) = ($_->{"string"}, $_->{"type"});
						if ($type eq 'command') {
							$cmd = meta2string($cmd, \%values);
							debug(1, "Executing (from $keyname):");
							debug(1, "$cmd");
							system($cmd);
						} elsif ($type eq 'perl') {
							my ($d, $v, $s);
							$storage->{$log}->{$keyname} = {} if (!exists($storage->{$log}->{$keyname}));
							$d = $storage->{$log}->{$keyname};
							map { $s->{$_} = $fileconf->{$_} } qw(threshold count interval);
							$v = \%values;
							eval($cmd);
							warn $@ if $@;
						} else {
							debug(0, sprintf("Unknown execution type: %s. %s", $type, $cmd));
						}
					} @{$fileconf->{"reactions"}};
				} else { 
					$state->{$keyname}->{"time"} = time();
				}
				$state->{$keyname}->{"count"} = 0;
			}
			$last->{"values"} = \%values;
			$last->{"handler"} = $PATTERNS->{$log}->{$pattern};
		}
	}
	$state->{"last"}->{$log} = $last unless ($syslogmode);
}

sub pattern2regex {
	my $pattern = shift;
	my $regex = $pattern;
	my $orig = $pattern;

	my $count;
	do {
		my $rounds = 0;
		$count = 0;
		# Replace %KEY:SUBNAME% with a regex and store the capture as KEY:SUBNAME
		# The :SUBNAME specification is optional, ie; %IP% is valid, as is %IP:FOO%
		map { $count += $regex =~ s/%(($_)(?::\w+)?)%/($MATCH{$_})(?{ \$values{'$1'} = \$^N })/g; } keys(%MATCH);
		$rounds++;
		if ($rounds > 10) {
			debug(0, "Deep recursion translating '$orig'");
			last;
		}
	} while ($count > 0);

	return $regex;
}

sub meta2string {
	my $meta = shift;
	my $values = shift;
	my $orig = $meta;

	my $rounds = 0;
	my $count;
	do {
		$count = 0;
		#map { $count += $meta =~ s/%($_)%/$values->{$_}/g; } keys(%MATCH);

		# XXX: This will be undef if the key in $values is null, should that ever happen?
		map {
			my $regex = qr/%(\Q$_\E(?::\w+)?)(?:\|(\w+))?%/;
			while ($meta =~ m/$regex/) {
				$count++;
				my $data = data($values, $1, $2);
				$meta =~ s/$regex/$data/;
			}
			#$count += $meta =~ s/%($_(?::\w+)?)(\|\w+)?%/&data($values, $1, $2)/g; 
		} (keys(%MATCH), '=LINE', '=MATCH');
		$rounds++;
		if ($rounds > 10) {
			debug(0, "Deep recursion translating '$orig'");
			last;
		}
	} while ($count > 0);

	return $meta;
}

sub data {
	my ($values, $key, $opts) = @_;
	$opts //= "";
	my $ret = $values->{$key};

	# Escape anything that may cause shell execution to break
	if ($opts eq 'sh') {
		$ret =~ s/([(){}[\]\$*?!|;'"])/\\$1/g;
	}

	return $ret;
}

sub readconfig {
	my $cfname = shift || "logwatch.conf";
	debug(2, "Reading from $cfname");
	my $grammar = << 'GRAMMAR';
config: <rulevar: local $config = { }>
config: (file | pattern | ignorable )(s) /\Z/ { $return = $config }
ignorable: (comment | blankline)(s)
comment: /#[^\n]*/
blankline: /^\s*\n/

#error: /^[^\Z\n]/ { main::debug(0, "Error on line: $thisline ? (missing a semicolon perhaps?)"); }

string: /((?:\")(?:[^\\\"]*(?:\\.[^\\\"]*)*)(?:\")|(?:\')(?:[^\\\']*(?:\\.[^\\\']*)*)(?:\')|(?:\`)(?:[^\\\`]*(?:\\.[^\\\`]*)*)(?:\`))/ { $return = substr($item[1],1,-1) }
#string: <perl_quotelike> { $return = $item[1]->[2] }
number: /\d+/
word: /\w+/
perlblock: <perl_codeblock>

pattern: <rulevar: local $pattern = { }>
pattern: 'patterns' '{' (pattern_entry)(s) '}' ';' { $config->{"patterns"} = $pattern }
pattern_entry: pattern_name '=' pattern_string ';' { $pattern->{$item[1]} = $item[3] }
pattern_name: word
pattern_string: string

file: <rulevar: local $file = { }>
file: filespec filename '{' file_entry(?) '}' ';' { $config->{$item[2]} = $file }
filespec: ('file' | 'exec') { $file->{'type'} = $item[1] }
filename: string
file_entry: (file_entry_line | ignorable)(s)
file_entry_line: (syslog | type) ';'

syslog: 'syslog' '=' number { $file->{"syslog"} = $item[3] }

type: <rulevar: local $type = { }>
type: 'type' typename '{' type_entry '}' { $file->{"types"}->{$item[2]} = $type }
typename: string
type_entry: (((match | threshold | interval | reaction | key) ';') | ignorable)(s)

match: 'match' '=' string { push(@{$type->{"matches"}},$item[3]) }
threshold: 'threshold' '=' number { $type->{"threshold"} = $item[3] }
interval: 'interval' '=' number { $type->{"interval"} = $item[3] }
key: 'key' '=' string { $type->{"key"} = $item[3] }
reaction: 'reaction' '=' reactionspec { push(@{$type->{"reactions"}}, $item[3]) }
reactionspec: string { $return = { type => "command", string => $item[1] } } 
				  | perlblock { $return = { type => "perl", string => $item[1] } }
GRAMMAR

	my $parser = Parse::RecDescent->new($grammar);
	my $config;
	local $/ = undef;
	open(CONFIG, $cfname) or die("Unable to open: $cfname");
	$config = $parser->config(<CONFIG>);
	close(CONFIG);

	return $config;
}

sub setup {
	my $config = shift;
	debug(1, "Watching: " . join(", ", keys(%$config)));
	foreach my $file (keys(%{$config})) {
		my $matches = $config->{$file}->{"types"};
		my $matchhash;
		foreach my $match (keys(%{$matches})) {
			debug(2, "Match: $match");
			foreach my $string (@{$matches->{$match}->{"matches"}}) {
				debug(2, "String: $string");
				$matchhash->{$string} = $match;
			}
			$matches->{$match}->{"interval"} ||= 0;
			$matches->{$match}->{"threshold"} ||= 0;

			# Normalize perl blocks ?
			map {
				if ($_->{"type"} eq 'perl') {
					$_->{"string"} =~ s/^\s*{\s*(.*)\s*}\s*$/$1/;
					#"Perl: " . $_->{"string"} . "\n";
				}
			} @{$matches->{$match}->{"reactions"}};
				
		}
		$PATTERNS->{$file} = $matchhash;
	}

	foreach my $pattern (keys(%{$config->{"patterns"}})) {
		debug(2, "Adding pattern '$pattern'");
		$MATCH{$pattern} = $config->{"patterns"}->{$pattern};
	}
}
