#!/usr/bin/perl

use strict;
use warnings;
use Symbol;
use Data::Dumper;

# pragma - allow (?{ code }) assertions in
# dynamically generated regexen.
use re 'eval';

# Things you'll need to have installed:
use File::Tail;
use Regexp::Common qw(RE_ALL);
use Parse::RecDescent;

my @lognames = qw(/var/log/auth.log);
my @logrefs;

my $PATTERNS;
	
# Pattern-space wildcards, used as %WILDCARD% in the pattern config
my %MATCH = (
	USERNAME => '\\w+',
	IP => $RE{net}{IPv4},
	PORT => '\\d+',
	COUNT => '\\d+',
);

my $config = readconfig();
print Dumper($config);
setup($config);

# Keep state
my $state;

foreach (@lognames) {
	push(@logrefs, File::Tail->new(name => "$_", maxinterval => 1, interval => 1));
}

while(1) {
	my ($num,$timeleft,@pending) = File::Tail::select(undef,undef,undef,1,@logrefs);
	if ($num) {
		foreach (@pending) {
			handle($_);
		}
	}
}

sub handle {
	my ($log) = shift;
	my $line = $log->read();
	#print $log->{"input"} . "> " . $line;
	my $last = { line => $line };
	my $patterns = $PATTERNS->{$log->{"input"}};
	foreach my $pattern (keys(%{$patterns})) {
		# "fix" the line, turn it into a regex.
		my $regex = pattern2regex($pattern);
		#print "\n";
		#print "Line: $line\n";
		#print "Pattern: $pattern\n";
		#print "Regex: $regex\n";

		# The regex match will store keys in this hash
		my %values;
		if ($line =~ /$regex/) { 
			# Handle if we're over the threshold
			my $pat = $PATTERNS->{$log->{"input"}}->{$pattern};
			my $keyname = "$pat / $values{IP}";
			$state->{$keyname}->{"time"} ||= time();
			$state->{$keyname}->{"count"}++;

			print "Matched $keyname\n";
			print "Pattern: $pattern\n";
			#print "Regex: $regex\n";

			my $fileconf = $config->{$log->{"input"}}->{"types"}->{$pat};
			if ($state->{$keyname}->{"count"} >= $fileconf->{"threshold"})  {
				if (time() - ($state->{$keyname}->{"time"}) <= $fileconf->{"interval"}) { 
					#print "Reaction: " . $fileconf->{"reaction"} . "\n";
					my $reaction = $fileconf->{"reaction"};
					#print "Reaction: $reaction\n";
					$reaction = meta2string($reaction, \%values);
					print "Reaction: $reaction\n";
					system($reaction);
				} else { 
					$state->{$keyname}->{"time"} = time();
				}
				$state->{$keyname}->{"count"} = 0;
			}
			$last->{"values"} = %values;
			$last->{"handler"} = $PATTERNS->{$log->{"input"}}->{$pattern};
		}
	}
	$log->{"last"} = $last;
}

sub pattern2regex {
	my $pattern = shift;
	my $regex = $pattern;
	my $orig = $pattern;

	my $rounds = 0;
	my $count;
	do {
		$count = 0;
		map { $regex =~ s/%($_)%/($MATCH{$_})(?{\$values{$1} = \$^N})/g; } keys(%MATCH);
		$rounds++;
		if ($rounds > 10) {
			print STDERR "!!! Deep recursion translating '$orig'\n";
			last;
		}
	} while ($count > 0);

	return $regex;
}

sub meta2string {
	my $meta = shift;
	my $values = shift;
	my $orig = $meta;

	my $rounds = 0;
	my $count;
	do {
		$count = 0;
		map { $count += $meta =~ s/%($_)%/$values->{$_}/g; } keys(%MATCH);
		$rounds++;
		if ($rounds > 10) {
			print STDERR "!!! Deep recursion translating '$orig'\n";
			last;
		}
	} while ($count > 0);

	return $meta;
}

sub readconfig {
	my $cfname = "logwatch.conf";
	my $grammar = << 'GRAMMAR';
config: <rulevar: local $config = { }>
config: (ignorable | file | pattern)(s) /\Z/ { $return = $config }
ignorable: (comment | blankline)(s)
comment: /#[^\n]*/
blankline: /^\s+?\n/

string: /((?:\")(?:[^\\\"]*(?:\\.[^\\\"]*)*)(?:\")|(?:\')(?:[^\\\']*(?:\\.[^\\\']*)*)(?:\')|(?:\`)(?:[^\\\`]*(?:\\.[^\\\`]*)*)(?:\`))/ { $return = substr($item[1],1,-1) }
number: /\d+/
word: /\w+/

pattern: <rulevar: local $pattern = { }>
pattern: 'patterns' '{' (pattern_entry)(s) '}' ';' { $config->{"patterns"} = $pattern }
pattern_entry: pattern_name '=' pattern_string ';' { $pattern->{$item[1]} = $item[3] }
pattern_name: word
pattern_string: string

file: <rulevar: local $file = { }>
file: 'file' filename '{' file_entry(?) '}' ';' { $config->{$item[2]} = $file }
filename: string
file_entry: (file_entry_line | ignorable)(s)
file_entry_line: (syslog | type) ';'

syslog: 'syslog' '=' number { $file->{"syslog"} = $item[3] }

type: <rulevar: local $type = { }>
type: 'type' typename '{' type_entry '}' { $file->{"types"}->{$item[2]} = $type }
typename: string
type_entry: (((match | threshold | interval | reaction) ';') | ignorable)(s)

match: 'match' '=' string { push(@{$type->{"matches"}},$item[3]) }
threshold: 'threshold' '=' number { $type->{"threshold"} = $item[3] }
interval: 'interval' '=' number { $type->{"interval"} = $item[3] }
reaction: 'reaction' '=' string { $type->{"reaction"} = $item[3] }
GRAMMAR

	my $parser = Parse::RecDescent->new($grammar);
	my $config;
	open(CONFIG, "logwatch.conf") or return;
	undef $/;
	$config = $parser->config(<CONFIG>);
	close(CONFIG);

	return $config;
}

sub setup {
	my $config = shift;
	print "Files to watch: " . join(", ", keys(%$config)) . "\n";
	foreach my $file (keys(%{$config})) {
		print "File: $file\n";
		my $matches = $config->{$file}->{"types"};
		my $matchhash;
		foreach my $match (keys(%{$matches})) {
			print "Match: $match\n";
			foreach my $string (@{$matches->{$match}->{"matches"}}) {
				print "String: $string\n";
				$matchhash->{$string} = $match;
			}
		}
		$PATTERNS->{$file} = $matchhash;
	}

	foreach my $pattern (keys(%{$config->{"patterns"}})) {
		$MATCH{$pattern} = $config->{"patterns"}->{$pattern};
	}
}
