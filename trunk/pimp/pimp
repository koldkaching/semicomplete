#!/usr/bin/perl
# (?:Perl|Pretty)i?\sMusic\sPlayer
# or...
# Pimp Is a Music Player
#
# Anyhoo... on with the perl!
# $Id$

use strict;
use warnings;

use Audio::Ao qw(:all);
use Audio::Mad qw(:all);
use Audio::Mixer;
#use File::Glob qw(:glob);
use IO::Handle;
use IO::Select;
use IO::Socket;
use MP3::Tag;
use POSIX;
use Socket;
use URI;

use HTTP::Handle;

use constant ERR_DECODE => "1";
use constant ERR_EOF => "2";

$SIG{INT} = \&do_shutdown;
$SIG{__DIE__} = \&do_shutdown;

my ($serv, $player) = IO::Socket->socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
my $BUFSIZE = 8192;
my $MAXBUFSIZE = 65536;

my $pimp = { };

# MP3 Player writes to $server, reads from $player
# Server writes to $player, reads from $server

my $spid = fork();
if ($spid == 0) {
	run_server();
	die("Server died!\n");
}


$pimp->{"HTTP_SERVER"} = IO::Socket::INET->new( Proto => "tcp",
													  LocalPort => "8080",
													  Listen => SOMAXCONN,
													  Reuse => 1);
$pimp->{"HTTP_SELECT"} = IO::Select->new($pimp->{"HTTP_SERVER"});
$pimp->{"HTTP_CLIENTS"} = { };

my $stream   = new Audio::Mad::Stream();
my $frame    = new Audio::Mad::Frame();
my $synth    = new Audio::Mad::Synth();
my $timer    = new Audio::Mad::Timer();
my $resample = new Audio::Mad::Resample(22050, 44100);
my $dither   = new Audio::Mad::Dither();

my @playlist;
read_playlist();
next_song();

initialize_ao;
my $device = open_live(default_driver_id(), 16, 44100, 2, is_big_endian(), {});
die ("Unable to open sound device.\n") unless defined($device);
$pimp->{"sound_device"} = $device;
$pimp->{"sound_state"} = 1;

my $select = IO::Select->new($player);

#my $buffer = ""; # IPC buffer
$pimp->{"state"} = "playing";

while (1) {
	foreach my $socket ($select->can_read(.01)) {
		my $data;
		my $recv = $socket->recv($data, POSIX::BUFSIZ, 0);
		$pimp->{"server_buffer"} .= $data;

		unless (defined($recv) && length($data)) {
			die("Connection to server was lost!? - $!\n");
		}

		while ($pimp->{"server_buffer"} =~ s!(.*\n)!!) {
			handle_command($1);
		}
	}

	play_loop();

	handle_one_event();

	handle_http_requests();
}

# Subs!

sub signal_event {
	push(@{$pimp->{"event_queue"}}, { event => shift, data => shift });
}

sub handle_one_event {
	my $e = shift(@{$pimp->{"event_queue"}});
	return if (!defined($e));

	my ($event, $data);
	$event = $e->{"event"};
	$data = $e->{"data"};

	print "EVENT: $event\n";

	if ($event eq 'end_of_song') {
		stop_song();
		next_song();
	} elsif ($event eq 'new_song') {
		print $player "BROADCAST " . display_song($pimp->{"current_song"}) . "\n";
	} elsif ($event eq 'client_next_song') {
		stop_song();
		next_song();
	} elsif ($event eq 'client_pause') {
		$pimp->{"state"} = ($pimp->{"state"} eq "pause") ? "playing" : "pause";
		print $player "BROADCAST " . $pimp->{"state"} . "\n";
	} elsif ($event eq 'open_fail') {
		print $player "BROADCAST Failed trying to read file...\n";
		stop_song();
		next_song();
	}

}

sub play_loop {
	# Audio Stuff
	if ($pimp->{"state"} eq "playing") {
		if ($pimp->{"sound_state"} == 0) {
			$device = open_live(default_driver_id(), 16, 44100, 2, is_big_endian(), {});
			die ("Unable to open sound device.\n") unless defined($device);
			$pimp->{"sound_state"} = 1;
		}
		my $pcm;
		if ($pimp->{"current_type"} eq "mp3") {
			$pcm = decode_current_mp3();
			if ($pcm eq ERR_EOF) {
				signal_event("end_of_song");
			} elsif (defined($pcm) && $pcm ne '') {
				play($device, $pcm, length($pcm));
			} elsif ($pcm ne ERR_DECODE) {
				# End of song or something broke. (Non-decoding error)
				signal_event("end_of_song");
				$pimp->{"state"} = "stopped";
			}
		}
	}
}

# Decode a frame of our happy MP3
sub decode_current_mp3 {

	# Keep our internal prebuffer filled as best as we can...
	$pimp->{"current_buffer"} |= '';
	if (length($pimp->{"current_buffer"}) < $MAXBUFSIZE) {
		my $b = sysread($pimp->{"current_fd"}, $pimp->{"current_buffer"}, 
							 $MAXBUFSIZE - length($pimp->{"current_buffer"}), length($pimp->{"current_buffer"}));
		#print "Bufsize: " . length($pimp->{"current_buffer"}) . "\n";
	}


	# Yadda yadda yadda.
	while ($frame->decode($stream) == -1) {
		# If there's a buffer-related error, then we need to read more from 
		if ($stream->error() == MAD_ERROR_BUFLEN || 
			 $stream->error == MAD_ERROR_BUFPTR) {

			return ERR_EOF if length($pimp->{"current_buffer"}) == 0;
			my $buffer = substr($pimp->{"old_buffer"}, $stream->next_frame());
			$buffer .= substr($pimp->{"current_buffer"}, 0, $BUFSIZE);
			$pimp->{"current_buffer"} = substr($pimp->{"current_buffer"}, $BUFSIZE);
			#print "Slurped from buffer " . length($buffer) . " / " . length($pimp->{"current_buffer"}) . "\n";

			$stream->buffer($buffer);
			$pimp->{"old_buffer"} = $buffer;

			# This breaks the music 
			#return ERR_DECODE;
		} else {
			return ERR_EOF unless ($stream->err_ok());
		}
	}

	$synth->synth($frame);

	my @samples = $synth->samples();

	map { 
		syswrite($_, $pimp->{"old_buffer"}, $stream->next_frame() - $stream->this_frame(), $stream->this_frame);
	} values(%{$pimp->{"HTTP_CLIENTS"}});

	# $frame->samplerate() shows us the bitrate.
	$pimp->{"current_samplerate"} |= 0;
	if ( ($frame->samplerate() != $pimp->{"current_samplerate"}) ) {
		#print "Creating sampler for: " . $frame->samplerate() . " -> 44100\n";
		$pimp->{"current_samplerate"} = $frame->samplerate();

		# if @samples has 2 items, this is a stereo stream
		# if not, this is a mono stream
		#if (scalar(@samples) != 2) {
		if ($frame->NCHANNELS == 1) {
			$resample->init($frame->samplerate() / 2, 44100);
		} else {
			$resample->init($frame->samplerate(), 44100);
		}
	}

	return $dither->dither($resample->resample($synth->samples()))
		if ($frame->samplerate() != 44100);
	return $dither->dither($synth->samples());

}

sub handle_command {
	my $line = shift;
	my ($who, $cmd, $args) = split(/\s+/,$line,3);

	# Kill trailing whitespace
	$args =~ s/\s+$// if (defined($args));

	#print "Command: $cmd FROM $who\n";
	$cmd = lc($cmd);

	return unless defined($args);

	if ('pause' =~ m/^\Q$cmd\E/) {
		signal_event("client_pause", $player);
	} elsif ('play' =~ m/^\Q$cmd\E/) {
		if ($args =~ m!^http://!) {
			play_song($args);
			return;
		}

		if (defined($pimp->{"jump_lists"}->{"$who"}) && length($args) > 0) {
			my @files = @{$pimp->{"jump_lists"}->{"$who"}};

			if ($args =~ m/^(\d+)(-|\.\.)(\d+)$/) {
				my ($left, $right) = ($1 - 1, $3 - 1);
				play_song(@files[$left .. $right]);
			} elsif ($args =~ m/^\d+$/) {
				play_song($files[$args - 1]);
			} elsif ($args =~ m/^all$/i) {
				play_song(@files);
			}
			#delete $pimp->{"jump_lists"}->{"$who"};
		} else {	
			play_song($pimp->{"current_song"}->{"file"})
				if ($pimp->{"state"} =~ m/(?:playing|stop)/);
		}
		$pimp->{"state"} = "playing";

	} elsif ('queue' =~ m/^\Q$cmd\E/) {
		@{$pimp->{"jump_lists"}->{"$who"}} = () unless (defined($pimp->{"jump_lists"}->{"$who"}));
		my @files = @{$pimp->{"jump_lists"}->{"$who"}};

		if ($args =~ m/^(\d+)(-|\.\.)(\d+)$/) {
			my ($left, $right) = ($1 - 1, $3 - 1);
			push(@{$pimp->{"song_queue"}}, @files[$left .. $right]);
		} elsif ($args =~ m/^\d+$/) {
			push(@{$pimp->{"song_queue"}}, $files[$args - 1]);
		} elsif ($args =~ m/^all$/i) {
			push(@{$pimp->{"song_queue"}}, @files);
		} elsif ($args =~ m/^clear$/i) {
			print "Clear\n";
			$pimp->{"song_queue"} = [ ];
		} elsif ($args =~ m/^shuffle$/i) {
			array_shuffle($pimp->{"song_queue"});
		} else {
			map { my $a = $_; $a =~ s!^.*/!!g; print $player "$who $a\n" } @{$pimp->{"song_queue"}};
		}

		#delete $pimp->{"jump_lists"}->{"$who"};

	} elsif ('stop' =~ m/^\Q$cmd\E/) {
		$pimp->{"state"} = 'stop';

		# Shutdown sound
		if (close_ao($device)) {
			$pimp->{"sound_state"} = 0;
		} else {
			print STDERR "Unable to close sound?!\n";
		}
	} elsif ('next' =~ m/^\Q$cmd\E/) {
		signal_event("client_next_song");
		#next_song();
	} elsif ('quit' =~ m/^\Q$cmd\E/) {
		print $player "$who CLOSE\n";
	} elsif ('info' =~ m/^\Q$cmd\E/) {
		my $csong = $pimp->{"current_song"};
		print $player "$who " . display_song($csong) . "\n";
	} elsif ('jump' =~ m/^\Q$cmd\E/) {
		my @matches = @playlist;

		print $player "$who You are stupid :(\n" and return unless (length($args) > 0) ;

		map { my $a = $_; @matches = grep(/\Q$a\E/i, @matches); } split(/\s+/, $args);
		@{$pimp->{"jump_lists"}->{"$who"}} = @matches;

		#@matches = map { $_ =~ s!^.*/!!g; $_ } @matches;
		print $player "$who Files matching query: '$args'\n";

		my $x = 1;
		map { s!^.*/!!g; print $player "$who " . $x++ . ": $_\n" } @matches;

	} elsif ('jump' =~ m/^\Q$cmd\E/) {
		my $file = $pimp->{"current_song"}->{"file"};
		my ($tag,$value) = split(/\s+/,$args,2);
		chomp($value);
		$value =~ s!\r!!;
		$tag = lc($tag);
		if ($tag =~ m/(title|track|album|artist)/) {
			my $mp3 = MP3::Tag->new($file);
			$mp3->get_tags();
			my $id3 = $mp3->{ID3v1} || $mp3->new_tag("ID3v1");
			print $player "$who Setting $tag to '$value'\n";
			if ($tag eq 'title') {
				$id3->song($value);
			} elsif ($tag eq 'album') {
				$id3->album($value);
			} elsif ($tag eq 'artist') {
				$id3->artist($value);
			} elsif ($tag eq 'track') {
				$id3->track($value);
			} else {
				print $player "$who Invalid tag name, '$tag'\n";
				return;
			}
			$mp3->{ID3v1}->write_tag();
			my ($song, $track, $artist, $album) = $mp3->autoinfo();
			$pimp->{"playlist"}->{$file} = { title => $song, artist => $artist, 
				track => $track, album => $album,
				file => $file };
				$pimp->{"current_song"} = $pimp->{"playlist"}->{$file};
				$mp3->close();
		} else {
			print $player "$who Invalid tag name, '$tag'\n";
		}

	} elsif ('volume' =~ m/^\Q$cmd\E/) {
		if (length($args) > 0) {
			if ($args =~ m/^\d+$/) {
				print $player "BROADCAST Volume set to: $args\n";
				Audio::Mixer::set_cval('vol', $args, $args);
			}
		} else {
			print $player "$who Volume is currently " . (Audio::Mixer::get_cval('vol'))[0] . "%\n";
		}
	}
}

sub display_song {
	# ($album) $artist - $title
	my $foo = shift;

	if ($pimp->{"current_is_stream"}) {
		#$0 = "PiMP: " . $foo->{"file"} . "\n";
		return $foo->{"file"} . "\n";
	} else {
		#$0 = "PiMP: ";
		#$0 .= sprintf("(%s) %s - %s", $foo->{"album"}, $foo->{"artist"}, 
							#$foo->{"title"});
		return sprintf("(%s) %s - %s", $foo->{"artist"}, $foo->{"album"}, 
							$foo->{"title"});
	}
}

sub stop_song {
	if ($pimp->{"current_type"} eq "mp3") {
		close($pimp->{"current_fd"}) or warn("Failed closing fd: $!");;
	}
}

sub next_song {
	# Find next song to play
	# Then play it
	my $newsong;

	if (defined($pimp->{"song_queue"}) && (scalar(@{$pimp->{"song_queue"}}) > 0)) {
		$newsong = shift(@{$pimp->{"song_queue"}});
	}  else {
		$newsong = $playlist[ (int(rand() * scalar(@playlist))) ];
	}
	print STDERR "New song: $newsong\n";

	play_song($newsong);
}

sub play_song {
	my @files = @_;
	my $file = shift(@files);
	my $buffer = '';

	if (scalar(@files) > 0) {
		push(@{$pimp->{"song_queue"}}, @files);
	}

	my $fd;

	if ($file =~ m!^http:\/\/!) {
		print "HTTP!\n";
		my $http = HTTP::Handle->new();
		$http->url($file);
		$http->connect();
		$fd = $http->fd();
		$pimp->{"current_is_stream"} = 1;
	} elsif ($file =~ m/\.mp3$/) {
		open($fd, $file) or signal_event("open_fail", $file) and return;
		$pimp->{"current_is_stream"} = 0;
	} else {
		signal_event("open_fail", $file) and return;
	}

	$pimp->{"current_type"} = "mp3";

	# Prebuffer stage
	print "Prebuffering\n";
	STDOUT->autoflush(1);
	while (length($buffer) < $MAXBUFSIZE / 2) {
		unless (sysread($fd, $buffer, $BUFSIZE, length($buffer))) {
			signal_event("read_fail", $file);
			warn("Failed in prebuffer stage for $file\n");
			return;
		}
	}
	print "done\n";
	$pimp->{"current_fd"} = $fd;
	$stream->buffer(substr($buffer, 0, $BUFSIZE));
	$pimp->{"old_buffer"} = substr($buffer, 0, $BUFSIZE);
	$pimp->{"current_buffer"} = substr($buffer, $BUFSIZE);;

	if (! $pimp->{"current_is_stream"}) {
		my $mp3 = MP3::Tag->new($file);
		my ($song, $track, $artist, $album) = $mp3->autoinfo();
		$pimp->{"playlist"}->{$file} = { title => $song, artist => $artist, 
			track => $track, album => $album,
			file => $file };
			$pimp->{"current_song"} = $pimp->{"playlist"}->{$file};
			$mp3->close();
	} else {
		$pimp->{"playlist"}->{$file} = { file => $file };
		$pimp->{"current_song"} = $pimp->{"playlist"}->{$file};
	}

	$pimp->{"state"} ||= "playing";
	$pimp->{"state"} = "playing" if ($pimp->{"state"} eq "pause");

	$pimp->{"current_timer"} = new Audio::Mad::Timer();
	signal_event("new_song");


}

###
# SERVER STUFF

sub run_server {
	close(STDIN);
	my (%ready, %buffers);

	$SIG{TERM} = \&server_sigterm;

	my $select = IO::Select->new();
	my $server = IO::Socket::INET->new( Proto => "tcp",
													LocalPort => "3242",
													Listen => SOMAXCONN,
													Reuse => 1);
	$select->add($server);
	$select->add($serv);
	#nonblock($server);

	my $clients = {};
	$clients->{"$serv"} = $serv;

	$pimp->{"clients"} = $clients;

	while (1) {
		my $socket;

		foreach $socket ($select->can_read(1)) {
			if ($socket == $server) {  # Incomming Clients
				my $client = $server->accept();
				$select->add($client);
				$clients->{"$client"} = $client;
			} else {
				my $data;
				my $recv = $socket->recv($data, POSIX::BUFSIZ, 0);

				unless (defined($recv) && length($data)) {
					# Client disconnected, clean up.
					drop_client($socket, \%ready, \%buffers, $clients, $select);
					next;
				} 

				$buffers{$socket} .= $data;

				while ($buffers{$socket} =~ s!(.*\n)!!) {
					push( @{$ready{$socket}}, $1 );
				}
			}	
		}

		foreach my $client (keys(%ready)) {
			handle($clients, $client, \%ready, \%buffers, $select);
			delete($ready{$client});
		}
	}
}

sub server_sigterm {
	my $clients = $pimp->{"clients"};

	foreach my $client (values(%{$clients})) {
		print $client "Server is quitting... Good bye :)\n";
		drop_client($client);
	}
}

sub handle {
	my $clients = shift;
	my $client = shift;
	my ($ready, $buffers, $select) = @_;
	my $lines = \@{$ready->{$client}};
	if ($client eq $serv) {
		foreach my $line (@{$lines}) {
			my ($who, $resp) = split(/\s+/,$line,2);
			if ($who eq 'BROADCAST') {
				foreach $client (keys(%{$clients})) {
					next if ($client eq $serv);
					$client = $clients->{$client};
					print $client "$resp";
				}
			} else {
				$client = $clients->{$who};
				if ($resp eq "CLOSE\n") {
					drop_client($client, $ready, $buffers, $clients, $select);
				} else {
					print $client "$resp" if (defined($client));
				}
			}
		}
	} else {
		map { print $serv "$client $_" } @{$lines};
	}
}

sub drop_client {
	my $socket = shift;
	my ($ready, $buffers, $clients, $select) = @_;
	delete $ready->{$socket} if defined($ready);
	delete $buffers->{$socket} if defined($ready);
	delete $clients->{$socket} if defined($ready);
	$select->remove($socket) if defined($select);
	close($socket);
}

sub do_shutdown {
	my $error = shift;
	if ($error ne 'INT' ) {
		print STDERR "Fatal Error: $error\n";
	}
	close_ao($pimp->{"sound_device"});
	shutdown_ao;
	print STDERR "Dying...\n";
	kill("TERM", $spid);
	while ((my $child = waitpid(-1,WNOHANG)) > 0) {
		# meh..
	}
	exit 1;
}

sub read_playlist {
	my $file = $ARGV[0] || "/home/psionic/foo.m3u";
	open(LIST, "< $file");
	while (my $line = <LIST>) {
		next if ($line =~ m/^#/);
		chomp($line);
		push(@playlist,$line);# if ($line =~ m/\.mp3$/);
	}
}

sub array_shuffle {
	my $array = shift;
	my $i;
	for ($i = @{$array}; $i > 0; --$i) {
		my $j = int(rand($i + 1));

		@{$array}[$i, $j] = @{$array}[$j, $i];
	}
}


sub handle_http_requests {
	my $server = $pimp->{"HTTP_SERVER"};
	foreach my $socket ($pimp->{"HTTP_SELECT"}->can_read(0)) {
		my $client = $server->accept();
		$pimp->{"HTTP_CLIENTS"}->{"$client"} = $client;
		print $client "ICY 200 OK\n\n";
	}
}
