#!/usr/bin/perl 
# $Id$

use strict;
use IO::Select;
use Net::OSCAR;
use POSIX qw(strftime);
use Term::ReadKey;
use Term::Size;

# Super-magical happy land!
use Tic::Constants; 
use Tic::Bindings;
use Tic::Common;
use Tic::Commands;
use Tic::Events;

ReadMode(3);

mkdir($ENV{HOME}."/.tic", "0700") unless (-d $ENV{HOME} . "/.tic");

my $aliases = undef;   # Aliases
my $commands = undef;  # Commands
my $bindings = DEFAULT_BINDINGS; 
my $mappings = DEFAULT_MAPPINGS;
my $config = DEFAULT_OUTPUT;

my $settings = read_config($ENV{HOME}."/.ticrc");

my $state = undef;     # State information
$state->{"bindings"} = $bindings; 
$state->{"mappings"} = $mappings; 
$state->{"config"} = $config;
$state->{"settings"} = $settings;

($state->{"termcols"}) = Term::Size::chars();
out("Columns: " . $state->{"termcols"});

my $aim = Net::OSCAR->new();
#$aim->timeout(1);
$state->{"aim"} = $aim;

setup_callbacks();
setup_commands();

Tic::Events->set_state($state);
Tic::Commands->set_state($state);
Tic::Bindings->set_state($state);
Tic::Common->set_state($state);

prepare_completion($commands);

# Autoflush stdout.
$| = 1;

login($settings->{"screenname"}, $settings->{"password"});

# What is this?!
# - When we call check_readline() and there's nothing to read, we want
#   to allow parsing of aim events.
# 
# What for?
# Without using an "aimok" state (telling when it's ok to process
# aim events), we will process aim event all the time. This becomes
# very time consuming; that is, pasting things takes a while.
# This new state solves it

$state->{"aimok"} = 1;

# $aim->do_one_loop() sleeps for .01 seconds waiting for data. This is time
# that could be better spent reading from the input. So, what I did
# is every time a key is read set $state->{"aimok"} to 0. And any time
# check_readline() does not read a keypress $state->{"aimok"} is set to 1.
# This makes it so pasting things is very fast because while you're pasting
# $aim->do_one_loop() is never called.

while (1) {
	$aim->do_one_loop() if ($state->{"aimok"});
	check_readline();
	#$state->{"aimok"} = 1 if ($state->{"is_typing"} < time());
}

# init functions

sub setup_callbacks {
	$aim->set_callback_admin_error(\&event_admin_error);
	$aim->set_callback_admin_ok(\&event_admin_ok);
	$aim->set_callback_buddy_in(\&event_buddy_in);
	$aim->set_callback_buddy_info(\&event_buddy_info);
	$aim->set_callback_buddy_out(\&event_buddy_out);
	$aim->set_callback_buddylist_error(\&event_buddylist_error);
	$aim->set_callback_buddylist_ok(\&event_buddylist_ok);
	$aim->set_callback_chat_buddy_in(\&event_chat_buddy_in);
	$aim->set_callback_chat_buddy_out(\&event_chat_buddy_out);
	$aim->set_callback_chat_closed(\&event_chat_closed);
	$aim->set_callback_chat_im_in(\&event_chat_im_in);
	$aim->set_callback_chat_invite(\&event_chat_invite);
	$aim->set_callback_chat_joined(\&event_chat_joined);
	$aim->set_callback_connection_changed(\&event_connection_changed);
	$aim->set_callback_error(\&event_error);
	$aim->set_callback_evil(\&event_evil);
	$aim->set_callback_im_in(\&event_im_in);
	$aim->set_callback_im_ok(\&event_im_ok);
	$aim->set_callback_rate_alert(\&event_rate_alert);
	$aim->set_callback_signon_done(\&event_signon_done);
}

sub setup_commands {
	$commands = {
		"alias"                   => \&command_alias,
		"buddylist"               => \&command_buddylist,
		"default"                 => \&command_default,
		"echo"                    => \&command_echo,
		"getaway"                 => \&command_getaway,
		"info"                    => \&command_info,
		"help"                    => \&command_help,
		"log"                     => \&command_log,
		"login"                   => \&command_login,
		"msg"                     => \&command_msg,
		"quit"                    => \&command_quit,
		"timestamp"               => \&command_timestamp,
		"unalias"                 => \&command_unalias,
		"undefault"               => \&command_undefault,
		"who"                     => \&command_who,
	};
	$aliases = {
		"a" => "/alias",
		"m" => "/msg",
		"i" => "/info",
		"b" => "/buddylist",
		"w" => "/who",
	};

	$state->{"aliases"} = $aliases;
	$state->{"commands"} = $commands;
}

# Nonblocking readline
sub check_readline { 
	my $char;

	# ReadKey(-1) means no timeout waiting for data, thus is nonblocking
	$char = ReadKey(-1);
	if (defined($char)) {
		if ($char eq "\n") {
			# 
			my $line = $state->{"input_line"};
			real_out("\n");
			$state->{"input_line"} = undef;
			$state->{"input_position"} = 0;

			# Instead of printing an EOL, we could have the commands each handle
			# outputting things themselves, so that things aren't so cluttered 
			# and messy looking?

			command($line);
			#$state->{"is_typing"} = 0;
			$state->{"aimok"} = 1;
			return;
		}

		# Returned (string, char, extrahash)
		my ($ret, $foo, $extra) =  handle_keys($state->{"input_line"},
								               $state->{"input_position"},
								               $char);
		#print STDERR "$ret / $foo / $extra\n";
		if (defined($ret)) {
			my $pos = $state->{"input_position"}; 
			my $back = length($ret) - $pos;
			if (defined($extra->{"-print"})) {
				real_out($extra->{"-print"});
			}
			real_out("\r\e[2K" . $ret);
			real_out("\e[".$back."D") if ($back > 0);
			$state->{"input_line"} = $ret;
		} else {
			if (defined($extra->{"-print"})) {
				real_out($extra->{"-print"});
			}
		}

		$state->{"aimok"} = 0;
		#$state->{"is_typing"} = time();
	} else {
		$state->{"aimok"} = 1;
	}
}

# blocking readline
sub readline {
   my ($hide) = shift;
   my ($char, $line);
   while (1) {
      $char = getc();
      last if ($char eq "\n");
      $line = handle_keys($line, length($line), $char);
   }

   return $line;
}

# Handle keys... and strife!
sub handle_keys {
   my ($line, $pos, $char) = @_;
	my $extra;

	if ($state->{"escape"}) {
		$state->{"escape_string"} .= $char;
		if ($state->{"escape_expect_ansi"}) {
			$state->{"escape_expect_ansi"} = 0 if ($char =~ m/[a-zA-Z]/);
		}
		$state->{"escape_expect_ansi"} = 1 if ($char eq '[');
		$state->{"escape"} = 0 unless ($state->{"escape_expect_ansi"});

		unless ($state->{"escape_expect_ansi"}) {
			my $estring = $state->{"escape_string"};

			$state->{"escape_string"} = undef;
			my (@foo) = execute_binding("\e".$estring);
			#print STDERR "Escape ret: " . scalar(@foo) . "\n";
			return @foo;
		}
		return undef;
	}

   if ($char eq "\e") {                   # Escape
		$state->{"escape"} = 1;
		$state->{"escape_string"} = undef;

		# Return undef becuase we don't know what to do yet.
		return undef; 
	} 

	if (ord($char) <= 26) {                # Control characters
		($line, $char, $extra) = execute_binding($char);
	}


	if ((defined($char)) && (ord($char) >= 32)) {
		$line = substr($line,0,$state->{"input_position"}) . $char . 
			     substr($line,$state->{"input_position"});
		$state->{"input_position"}++;
		#print STDERR "Position: " . $state->{"input_position"} . "\n";
	}

   return ($line, $char, $extra);
}

sub command {
	my ($cmd,$args) = split(/\s+/, $_[0], 2);

   if ($cmd =~ s!^/!!) {
		#out("<$cmd>");
		if (defined($commands->{$cmd})) { 
			&{$commands->{$cmd}}($state, $args);
		} elsif (defined($aliases->{$cmd})) {
			$state->{"recursion_check"}++;
			if ($state->{"recursion_check"} > 10) {
				out("Too much recursion in this alias. Aborting execution");
				return;
			}
			($cmd, $args) = $aliases->{$cmd} . " " . $args;
			command($cmd,$args);
			$state->{"recursion_check"}--;
		} else {
			out("Unknown command, \"$cmd\"");
		}
	} elsif ($cmd ne '') {
	   if ($_[0] =~ m/^;\s*(.*)$/) {
			if (($state->{"last_from"}) && ($1 ne '')) {
				command_msg($state,$state->{"last_from"}, $1);
				#$aim->send_im($state->{"last_from"}, $1);
			} else {
				error("No one has messaged you yet, how am I supposed to know who messaged you last?");
			}
		} else {
			if ($state->{"default"} ne '') {
				command_msg($state,$state->{"default"}, $_[0]);
				#$aim->send_im($state->{"default"}, $_[0]);
			}
		}
	}
}

sub execute_binding {
	my ($key) = shift;  # Could be a series, ESC-w
	$key = prettify_key($key);
	#print "Prettified key: $key\n";
	if (defined($bindings->{$key})) {
		#print STDERR "Key: $key\n";
		if (ref($mappings->{$bindings->{$key}}) eq 'CODE') {
			return &{$mappings->{$bindings->{$key}}}($state);
		} else {
			error("Unimplemented function, " . $bindings->{$key});
		}
	}
	return ($state->{"input_line"}, undef, undef);
}

sub prettify_key {
	my ($key) = shift;

	# Return ^X for control characters like CTRL+A and such.
	if (length($key) == 1) {     # Should only ever be control codes...
		if (ord($key) <= 26) {    # Control codes
			return "^" . chr(65 + ord($key) - 1);
		}
	}

	# Return ESC-X for escape shenanigans, like ESC-w
	if (length($key) == 2) {
		my ($p,$k) = split("", $key);
		if ($p eq "\e") {     # Escape character
			return "ESC-" . $k;
		}
	}

	# Ok, it's not ^X or ESC-X, it's gotta be some ansi funk.
	return KEY_CONSTANTS->{$key};
}

sub read_config {
	my ($file) = shift;

	if ( -r $file ) {
		my $conf;
		open(FILE,"< $file") or die("Failed trying to read $file (Unexpected!).\n$!\n");

		my $c = 0;
		while (my $line = <FILE>) {
			$c++;
			next if ($line =~ m/^#/);
			chomp($line);
			$line =~ s/#.*$//;
			if ($line =~ m/^(screenname|password|server|port)(?:\s|=)/i) {
				if ($line =~ m/(\S+)\s*=\s*(.+)$/) {
					print "$1 => $2\n";
					$conf->{lc($1)} = $2;
				} else {
					print STDERR "Syntax error on line $c of $file:\n$line\n";
				}
			} else {
				print STDERR "Invalid option on line $c of $file:\n$line\n";
			}
		}
		close(FILE);
		return $conf;
	} 
}
