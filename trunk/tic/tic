#!/usr/bin/perl 

use strict;
use IO::Select;
use IO::Stty;
use Term::ReadKey;
use Net::OSCAR;
use POSIX qw(strftime);

use Tic::Constants qw(KEY_CONSTANTS); # Super-magical happy land!
use Tic::Bindings qw(:DEFAULT);

ReadMode(3);

my $aliases = undef;   # Aliases
my $commands = undef;  # Commands
my $bindings = DEFAULT_BINDINGS; 
my $mappings = DEFAULT_MAPPINGS;

my $state = undef;     # State information
$state->{"bindings"} = $bindings;
$state->{"mappings"} = $mappings;

my $aim = Net::OSCAR->new();
#$aim->timeout(1);

setup_readline();
setup_callbacks();
setup_commands();
setup_aim();

#login();

$| = 1;

while (1) {
	#out("Signon: " . $state->{"signon"} . " / $aim");
	$aim->do_one_loop(); # if (($aim->is_on()) || ($state->{"signon"}));
	check_readline();
}

sub login {
	my ($user,$pass);
	$user = query("login: ");
	$pass = query("password: ", 1);
	$state->{"signon"} = 1;
	$aim->signon($user,$pass);
	#$aim->newconn(Screenname => $user, Password => $pass);
}

sub query {
	my ($q, $hide) = @_;
	real_out("$q");
	#stty("echo") unless ($hide);
	chomp($q = <STDIN>);
	#stty("-echo") if ($hide);
	out() if ($hide);
	return $q;
}

# Output functions

sub out { real_out(join("\n",@_) . "\n"); }

sub real_out { print STDOUT @_; }

sub error { print STDERR "*> " . shift() . "\n"; }

# init functions

sub setup_callbacks {
	$aim->set_callback_admin_error(\&event_admin_error);
	$aim->set_callback_admin_ok(\&event_admin_ok);
	$aim->set_callback_buddy_in(\&event_buddy_in);
	$aim->set_callback_buddy_info(\&event_buddy_info);
	$aim->set_callback_buddy_out(\&event_buddy_out);
	$aim->set_callback_buddylist_error(\&event_buddylist_error);
	$aim->set_callback_buddylist_ok(\&event_buddylist_ok);
	$aim->set_callback_chat_buddy_in(\&event_chat_buddy_in);
	$aim->set_callback_chat_buddy_out(\&event_chat_buddy_out);
	$aim->set_callback_chat_closed(\&event_chat_closed);
	$aim->set_callback_chat_im_in(\&event_chat_im_in);
	$aim->set_callback_chat_invite(\&event_chat_invite);
	$aim->set_callback_chat_joined(\&event_chat_joined);
	$aim->set_callback_connection_changed(\&event_connection_changed);
	$aim->set_callback_error(\&event_error);
	$aim->set_callback_evil(\&event_evil);
	$aim->set_callback_im_in(\&event_im_in);
	$aim->set_callback_im_ok(\&event_im_ok);
	$aim->set_callback_rate_alert(\&event_rate_alert);
	$aim->set_callback_signon_done(\&event_signon_done);

	#$conn->set_handler("admin_error", \&event_admin_error);
	#$conn->set_handler("admin_ok", \&event_admin_ok);
	#$conn->set_handler("buddy_in", \&event_buddy_in);
	#$conn->set_handler("buddy_info", \&event_buddy_info);
	#$conn->set_handler("buddy_out", \&event_buddy_out);
	#$conn->set_handler("buddylist_error", \&event_buddylist_error);
	#$conn->set_handler("buddylist_ok", \&event_buddylist_ok);
	#$conn->set_handler("chat_buddy_in", \&event_chat_buddy_in);
	#$conn->set_handler("chat_buddy_out", \&event_chat_buddy_out);
	#$conn->set_handler("chat_closed", \&event_chat_closed);
	#$conn->set_handler("chat_im_in", \&event_chat_im_in);
	#$conn->set_handler("chat_invite", \&event_chat_invite);
	#$conn->set_handler("chat_joined", \&event_chat_joined);
	#$conn->set_handler("error", \&event_error);
	#$conn->set_handler("evil", \&event_evil);
	#$conn->set_handler("im_in", \&event_im_in);
	#$conn->set_handler("im_ok", \&event_im_ok);
	#$conn->set_handler("rate_alert", \&event_rate_alert);
	#$conn->set_handler("signon_done", \&event_signon_done);
}

sub setup_readline {
	$state->{"input"} = IO::Select->new();
	$state->{"input"}->add(\*STDIN);
}

sub setup_aim {
	#$aim->timeout(1);
}

sub setup_commands {
	$commands = {
		"alias" => \&command_alias,     # Done
		"echo" => \&command_echo,       # Done
		"buddylist" => \&command_buddylist,
		"default" => \&command_default,
		"undefault" => \&command_undefault,
		"info" => \&command_info,       # Done
		"login" => \&command_login,     # Done but breaks
		"msg" => \&command_msg,         # Done
		"quit" => \&command_quit,       # Don
		"unalias" => \&command_unalias, # Done
		"who" => \&command_who,
	};
	$aliases = {
		"a" => "/alias",
		"m" => "/msg",
		"i" => "/info",
		"b" => "/buddylist",
		"w" => "/who",
	};

	$state->{"aliases"} = $aliases;
	$state->{"commands"} = $commands;
}

# Call backs

sub event_admin_error {
	my ($aim, $reqtype, $error, $errurl) = @_;
}

sub event_admin_ok {
	my ($aim, $reqtype) = @_;
}

sub event_buddy_in {
	my ($aim, $sn, $group, $data) = @_;
	if (!defined($state->{"buddylist"}->{$sn})) {
		out("* $sn ($group) is online.");
	} else {
		# Here we can add sections to output data
		# pertainting to the user's new state.
	}
	$state->{"buddylist"}->{$sn} = $data;

}

sub event_buddy_info {
	my ($aim, $sn, $data) = @_;
	foreach (@{$state->{"hooks"}->{"buddy_info"}}) {
		if ($sn eq $_->{sn}) {
			&{$_->{sub}}($sn);
			return;
		}
	}

	if ($data->{"profile"}) {
		out("Buddy info for $sn");
		out("------------------");
		if (1) { # If they have w3m...
			my $prof = $data->{'profile'};
			out(`echo "$prof" | lynx -dump -stdin`);
			#out(`echo "$prof" | w3m -T text/html -dump`);
		}
	} elsif ($data->{"awaymsg"}) {
	}

}

sub event_buddy_out {
	my ($aim, $sn, $group) = @_;
}

sub event_buddylist_error {
	my ($aim, $error, $what) = @_;
}

sub event_buddylist_ok {
	my ($aim) = @_;
}

sub event_chat_buddy_in {
	my ($aim, $sn, $chat, $data) = @_;
}

sub event_chat_buddy_out {
	my ($aim, $sn, $chat) = @_;
}

sub event_chat_closed {
	my ($aim, $chat, $error) = @_;
}

sub event_chat_im_in {
	my ($aim, $from, $chat, $msg) = @_;
}

sub event_connection_changed {
	my ($aim, $conn, $status) = @_;
}

sub event_error {
	my ($aim, $conn, $err, $desc, $fatal) = @_;
	error("$desc");
	if ($fatal) {
		error("This error was fatal and you have been disconnected. :(") ;
		$aim = Net::OSCAR->new();
		$state->{"signon"} = 0;
	}
	
}

sub event_evil {
	my ($aim, $newevil, $from) = @_; 
}

sub event_im_in {
	my ($aim, $from, $msg, $away) = @_;
	$state->{"last_from"} = $from;
	out("<*$from*> $msg");
}

sub event_im_ok {
	my ($aim, $to, $reqid) = @_;
}

sub event_rate_alert {
	my ($aim, $level, $clear, $window, $worrisome) = @_;
}

sub event_signon_done {
	my ($aim) = @_;
	$state->{"signon"} = 0;
}

# Useful pseudo events

sub event_is_away {
	
}

# stty! Saves previous stty state by default. If no params are passed then
# it will return the saved state.
sub stty {
	return $state->{"stty"} if (!defined($_[0]));
	#$state->{"stty"} = IO::Stty::stty(\*STDIN, "-g");
	return IO::Stty::stty(@_);
}

###
# Shenanigans!

sub add_hook {
	my ($hook, $data) = @_;
	push(@{$state->{"hooks"}->{$hook}}, $data);
}

# Nonblocking readline
sub check_readline { 
	my $char;
	$char = ReadKey(-1);
	if (defined($char)) {
		if ($char eq "\n") {
			real_out("\n");
			command($state->{"input_line"});
			$state->{"input_line"} = undef;
			$state->{"input_position"} = 0;
			return;
		}

		# Returned (string, char, extrahash)
		my ($ret, $foo, $extra) =  handle_keys($state->{"input_line"},
								               $state->{"input_position"},
								               $char);
		#print STDERR "$ret / $foo / $extra\n";
		if (defined($ret)) {
			my $pos = $state->{"input_position"}; 
			my $back = length($ret) - $pos;
			if (defined($extra->{"-print"})) {
				print STDERR "Extra!\n";
				real_out($extra->{"-print"});
			}
			real_out("\r\e[2K" . $ret);
			real_out("\e[".$back."D") if ($back > 0);
			$state->{"input_line"} = $ret;
		} else {
			if (defined($extra->{"-print"})) {
				print STDERR "Extra!\n";
				real_out($extra->{"-print"});
			}
		}
	}
}

# blocking readline
sub readline {
   my ($hide) = shift;
   my ($char, $line);
   while (1) {
      $char = getc();
      last if ($char eq "\n");
      $line = handle_keys($line, length($line), $char);
   }

   return $line;
}

# Handle keys... and strife!
sub handle_keys {
   my ($line, $pos, $char) = @_;
	my $extra;

	if ($state->{"escape"}) {
		$state->{"escape_string"} .= $char;
		if ($state->{"escape_expect_ansi"}) {
			$state->{"escape_expect_ansi"} = 0 if ($char =~ m/[a-zA-Z]/);
		}
		$state->{"escape_expect_ansi"} = 1 if ($char eq '[');
		$state->{"escape"} = 0 unless ($state->{"escape_expect_ansi"});

		unless ($state->{"escape_expect_ansi"}) {
			my $estring = $state->{"escape_string"};

			$state->{"escape_string"} = undef;
			my (@foo) = execute_binding("\e".$estring);
			print STDERR "Escape ret: " . scalar(@foo) . "\n";
			return @foo;
		}
		return undef;
	}

   if ($char eq "\e") {                   # Escape
		$state->{"escape"} = 1;
		$state->{"escape_string"} = undef;

		# Return undef becuase we don't know what to do yet.
		return undef; 
	} 

	if (ord($char) <= 26) {                # Control characters
		($line, $char, $extra) = execute_binding($char);
	}


	if ((defined($char)) && (ord($char) >= 32)) {
		$line = substr($line,0,$state->{"input_position"}) . $char . 
			     substr($line,$state->{"input_position"});
		$state->{"input_position"}++;
		#print STDERR "Position: " . $state->{"input_position"} . "\n";
	}

   return ($line, $char, $extra);
}

sub command {
	my ($cmd,$args) = split(/\s+/, $_[0], 2);

   if ($cmd =~ s!^/!!) {
		#out("<$cmd>");
		if (defined($commands->{$cmd})) { 
			&{$commands->{$cmd}}($args);
		} elsif (defined($aliases->{$cmd})) {
			$state->{"recursion_check"}++;
			if ($state->{"recursion_check"} > 10) {
				out("Too much recursion in this alias. Aborting execution");
				return;
			}
			($cmd, $args) = $aliases->{$cmd} . " " . $args;
			command($cmd,$args);
			$state->{"recursion_check"}--;
		} else {
			out("Unknown command, \"$cmd\"");
		}
	} elsif ($cmd !~ m/^$/) {
	   if ($_[0] =~ s/^;(.)/$1/) {
			if (($state->{"last_from"}) && ($_[0] =~ m/./)) {
				$aim->send_im($state->{"last_from"}, $_[0]);
			} else {
				error("No one has messaged you yet, how am I supposed to know who messaged you last?");
			}
		} else {
			if ($state->{"default"}) {
				$aim->send_im($state->{"default"}, $_[0]);
			}
		}
	}
}

sub create_alias {
	my ($alias, $cmd) = @_;
	$alias =~ s!^/!!;

	$aliases->{$alias} = $cmd;
}

sub remove_alias {
	my ($alias) = @_;

	undef($aliases->{$alias});
}

sub command_msg {
	my ($args) = shift;
	my ($sn, $msg) = split(/\s+/, $args, 2);
	
	$aim->send_im($sn, $msg);
}

sub command_alias {
	my ($args) = shift;
	my ($alias, $cmd) = split(/\s+/, $args, 2);

	if ($alias =~ m/^$/) {
		if (scalar(keys(%{$aliases})) == 0) {
			out("There are no aliases set.");
		} else {
			out("Aliases");
			out("--------------");
			foreach my $alias (keys(%{$aliases})) {
				next unless (defined($aliases->{$alias}));
				out("$alias => " . $aliases->{$alias});
			}
		}
		return;
	}

	if ($cmd =~ m/^$/) {
		if (defined($aliases->{$alias})) {
			out("$alias => " . $aliases->{$alias});
		} else {
			error("No such alias, \"$alias\"");
		}
	} else {
		create_alias($alias, $cmd);
	}
}

sub command_unalias {
	my ($args) = shift;
	my ($alias) = split(/\s+/, $args);

	if ($alias =~ m/^$/) {
		error("Unalias what?");
		return;
	}

	remove_alias($alias);
	out("Removed the alias \"/$alias\"");
}

sub command_echo {
	my ($args) = shift;
	out($args);
}

sub command_info {
	my ($sn,$key) = split(" ", $_[0]);

	if ($sn eq '') {
		error("Invalid number of arguments to /info.");
		return;
	}

	if ($key eq '') {
		out("Fetching user info for $sn");
		$aim->get_info($sn);
	} else {
		out("State info for $sn");
		out("$key: " . $aim->buddy($sn)->{$key});
	}
}

sub command_login {
	my ($args) = shift;
	if ($args eq '-f') {
		login();
	} else {
		if ($aim->is_on()) {
			error("You are already logged in, use /login -f to force reconnection.");
		} else {
			login();
		}
	}
}

sub command_quit {
	error("Bye :)");
	$aim->signoff();
	exit;
}

sub command_buddylist {
	my ($args) = shift;

	foreach my $g ($aim->groups()) {
		out($g);
		foreach my $b ($aim->buddies($g)) {
			my $bud = $aim->buddy($b,$g);

			my $extra;
			if ($bud) {
				$extra .= " [MOBILE]" if $bud->{mobile};
				$extra .= " [TYPINGSTATUS]" if $bud->{typingstatus};
				$extra .= " [ONLINE]" if $bud->{online};
				$extra .= " [TRIAL]" if $bud->{trial};
				$extra .= " [AOL]" if $bud->{aol};
				$extra .= " [FREE]" if $bud->{free};
				$extra .= " [AWAY]" if $bud->{away};
				$extra .= " {".$bud->{comment}."}" if defined $bud->{comment};
				$extra .= " {{".$bud->{alias}."}}" if defined $bud->{alias};
				$extra .= " (".$bud->{extended_status}.")" if defined $bud->{extended_status};
			}

			out("$b ($extra)");
		}
	}
}

sub command_default {
	my ($args) = shift;
	($args) = split(/\s+/,$args);

	if ($args eq '') {
		if ($state->{"default"}) {
			out("Default target: " . $state->{"default"});
		} else {
			error("No default target yet");
		}
	} else {
		if ($aim->buddy("$args")) {
			$state->{"default"} = $args;
			out("New default target: $args");
		} elsif ($args eq ';') {
			if ($state->{"last_from"}) {
				$state->{"default"} = $state->{"last_from"};
				out("New default target: " . $state->{"default"});
			} else {
				error("No one has sent you a message yet... what are you trying to do?!");
			}
		} else {
			error("The buddy $args is not on your buddylist, I won't default to it.");
		}
	}
}

sub command_undefault {
	out("Default target cleared.");
	undef($state->{"default"});
}

sub command_who {
	my ($args) = shift;

	foreach my $g ($aim->groups()) {
		out($g);
		my @buddies = $aim->buddies($g);
		foreach my $b (sort(compare($a,$b),@buddies)) {
			my $bud = $aim->buddy($b,$g);
			next unless (defined($bud));
			my $e;
			$e .= "offline" unless ($bud->{"online"});
			$e ||= "online, ";
			$e .= "away, " if ($bud->{"away"});
			$e .= "idle, " if ($bud->{"idle"});
			$e =~ s/, $//;

			out("    $b ($e)");

		}
	}
}

sub compare {
	#out("Compare $a and $b");
	local $a = buddyscore($a);
	local $b = buddyscore($b);
	return $a <=> $b;
}

sub buddyscore {
	my $buddy = shift;
	$buddy = $aim->buddy($buddy);
	my $sum = 0;
	return -11 if (!defined($buddy));

	$sum += 10 if ($buddy->{online});
	$sum -= 10 unless ($buddy->{online}); 
	$sum -= 5 if ($buddy->{away});
	$sum -= 3 if ($buddy->{idle});
	#out($buddy->{"screenname"} . " = $sum");

	return $sum;
}

sub execute_binding {
	my ($key) = shift;  # Could be a series, ESC-w
	$key = prettify_key($key);
	#print "Prettified key: $key\n";
	if (defined($bindings->{$key})) {
		#print STDERR "Key: $key\n";
		if (ref($mappings->{$bindings->{$key}}) eq 'CODE') {
			return &{$mappings->{$bindings->{$key}}}($state);
		} else {
			error("Unimplemented function, " . $bindings->{$key});
		}
	}
	return ($state->{"input_line"}, undef, undef);
}

sub prettify_key {
	my ($key) = shift;

	# Return ^X for control characters like CTRL+A and such.
	if (length($key) == 1) {     # Should only ever be control codes...
		if (ord($key) <= 26) {    # Control codes
			return "^" . chr(65 + ord($key) - 1);
		}
	}

	# Return ESC-X for escape shenanigans, like ESC-w
	if (length($key) == 2) {
		my ($p,$k) = split("", $key);
		if ($p eq "\e") {     # Escape character
			return "ESC-" . $k;
		}
	}

	# Ok, it's not ^X or ESC-X, it's gotta be some ansi funk.
	return KEY_CONSTANTS->{$key};
}
